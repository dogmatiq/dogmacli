// Code generated by Dogma CLI's build process. DO NOT EDIT.

package proto

import (
	"context"
	"encoding/json"
	"errors"
	harpy "github.com/dogmatiq/harpy"
)

// ---------------------------------------------------------------------------------------------------------------------
// REQUESTS
// ---------------------------------------------------------------------------------------------------------------------

// CallHierarchyIncomingCallsHandler handles "callHierarchy/incomingCalls" requests.
type CallHierarchyIncomingCallsHandler interface {
	// A request to resolve the incoming calls for a given `CallHierarchyItem`.
	//
	// @since 3.16.0
	HandleCallHierarchyIncomingCalls(
		context.Context,
		CallHierarchyIncomingCallsParams,
	) ([]CallHierarchyIncomingCall, error)
}

// CallHierarchyIncomingCallsRoute returns a route for the "callHierarchy/incomingCalls" request.
func CallHierarchyIncomingCallsRoute(h CallHierarchyIncomingCallsHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"callHierarchy/incomingCalls",
		h.HandleCallHierarchyIncomingCalls,
	)
}

// CallHierarchyOutgoingCallsHandler handles "callHierarchy/outgoingCalls" requests.
type CallHierarchyOutgoingCallsHandler interface {
	// A request to resolve the outgoing calls for a given `CallHierarchyItem`.
	//
	// @since 3.16.0
	HandleCallHierarchyOutgoingCalls(
		context.Context,
		CallHierarchyOutgoingCallsParams,
	) ([]CallHierarchyOutgoingCall, error)
}

// CallHierarchyOutgoingCallsRoute returns a route for the "callHierarchy/outgoingCalls" request.
func CallHierarchyOutgoingCallsRoute(h CallHierarchyOutgoingCallsHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"callHierarchy/outgoingCalls",
		h.HandleCallHierarchyOutgoingCalls,
	)
}

// CodeActionResolveHandler handles "codeAction/resolve" requests.
type CodeActionResolveHandler interface {
	// Request to resolve additional information for a given code action.The request's
	// parameter is of type {@link CodeAction} the response
	// is of type {@link CodeAction} or a Thenable that resolves to such.
	HandleCodeActionResolve(
		context.Context,
		CodeAction,
	) (CodeAction, error)
}

// CodeActionResolveRoute returns a route for the "codeAction/resolve" request.
func CodeActionResolveRoute(h CodeActionResolveHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"codeAction/resolve",
		h.HandleCodeActionResolve,
	)
}

// CodeLensResolveHandler handles "codeLens/resolve" requests.
type CodeLensResolveHandler interface {
	// A request to resolve a command for a given code lens.
	HandleCodeLensResolve(
		context.Context,
		CodeLens,
	) (CodeLens, error)
}

// CodeLensResolveRoute returns a route for the "codeLens/resolve" request.
func CodeLensResolveRoute(h CodeLensResolveHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"codeLens/resolve",
		h.HandleCodeLensResolve,
	)
}

// CompletionItemResolveHandler handles "completionItem/resolve" requests.
type CompletionItemResolveHandler interface {
	// Request to resolve additional information for a given completion item.The request's
	// parameter is of type {@link CompletionItem} the response
	// is of type {@link CompletionItem} or a Thenable that resolves to such.
	HandleCompletionItemResolve(
		context.Context,
		CompletionItem,
	) (CompletionItem, error)
}

// CompletionItemResolveRoute returns a route for the "completionItem/resolve" request.
func CompletionItemResolveRoute(h CompletionItemResolveHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"completionItem/resolve",
		h.HandleCompletionItemResolve,
	)
}

// DocumentLinkResolveHandler handles "documentLink/resolve" requests.
type DocumentLinkResolveHandler interface {
	// Request to resolve additional information for a given document link. The request's
	// parameter is of type {@link DocumentLink} the response
	// is of type {@link DocumentLink} or a Thenable that resolves to such.
	HandleDocumentLinkResolve(
		context.Context,
		DocumentLink,
	) (DocumentLink, error)
}

// DocumentLinkResolveRoute returns a route for the "documentLink/resolve" request.
func DocumentLinkResolveRoute(h DocumentLinkResolveHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"documentLink/resolve",
		h.HandleDocumentLinkResolve,
	)
}

// InitializeHandler handles "initialize" requests.
type InitializeHandler interface {
	// The initialize request is sent from the client to the server.
	// It is sent once as the request after starting up the server.
	// The requests parameter is of type {@link InitializeParams}
	// the response if of type {@link InitializeResult} of a Thenable that
	// resolves to such.
	HandleInitialize(
		context.Context,
		InitializeParams,
	) (InitializeResult, error)
}

// InitializeRoute returns a route for the "initialize" request.
func InitializeRoute(h InitializeHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"initialize",
		h.HandleInitialize,
	)
}

// InlayHintResolveHandler handles "inlayHint/resolve" requests.
type InlayHintResolveHandler interface {
	// A request to resolve additional properties for an inlay hint.
	// The request's parameter is of type {@link InlayHint}, the response is
	// of type {@link InlayHint} or a Thenable that resolves to such.
	//
	// @since 3.17.0
	HandleInlayHintResolve(
		context.Context,
		InlayHint,
	) (InlayHint, error)
}

// InlayHintResolveRoute returns a route for the "inlayHint/resolve" request.
func InlayHintResolveRoute(h InlayHintResolveHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"inlayHint/resolve",
		h.HandleInlayHintResolve,
	)
}

// ShutdownHandler handles "shutdown" requests.
type ShutdownHandler interface {
	// A shutdown request is sent from the client to the server.
	// It is sent once when the client decides to shutdown the
	// server. The only notification that is sent after a shutdown request
	// is the exit event.
	HandleShutdown(
		context.Context,
	) error
}

// ShutdownRoute returns a route for the "shutdown" request.
func ShutdownRoute(h ShutdownHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"shutdown",
		func(ctx context.Context, _ struct{}) (any, error) {
			return nil, h.HandleShutdown(ctx)
		},
	)
}

// TextDocumentCodeActionHandler handles "textDocument/codeAction" requests.
type TextDocumentCodeActionHandler interface {
	// A request to provide commands for the given text document and range.
	HandleTextDocumentCodeAction(
		context.Context,
		CodeActionParams,
	) ([]OneOf2[Command, CodeAction], error)
}

// TextDocumentCodeActionRoute returns a route for the "textDocument/codeAction" request.
func TextDocumentCodeActionRoute(h TextDocumentCodeActionHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/codeAction",
		h.HandleTextDocumentCodeAction,
	)
}

// TextDocumentCodeLensHandler handles "textDocument/codeLens" requests.
type TextDocumentCodeLensHandler interface {
	// A request to provide code lens for the given text document.
	HandleTextDocumentCodeLens(
		context.Context,
		CodeLensParams,
	) ([]CodeLens, error)
}

// TextDocumentCodeLensRoute returns a route for the "textDocument/codeLens" request.
func TextDocumentCodeLensRoute(h TextDocumentCodeLensHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/codeLens",
		h.HandleTextDocumentCodeLens,
	)
}

// TextDocumentColorPresentationHandler handles "textDocument/colorPresentation" requests.
type TextDocumentColorPresentationHandler interface {
	// A request to list all presentation for a color. The request's
	// parameter is of type {@link ColorPresentationParams} the
	// response is of type {@link ColorInformation ColorInformation[]} or a Thenable
	// that resolves to such.
	HandleTextDocumentColorPresentation(
		context.Context,
		ColorPresentationParams,
	) ([]ColorPresentation, error)
}

// TextDocumentColorPresentationRoute returns a route for the "textDocument/colorPresentation" request.
func TextDocumentColorPresentationRoute(h TextDocumentColorPresentationHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/colorPresentation",
		h.HandleTextDocumentColorPresentation,
	)
}

// TextDocumentCompletionHandler handles "textDocument/completion" requests.
type TextDocumentCompletionHandler interface {
	// Request to request completion at a given text document position. The request's
	// parameter is of type {@link TextDocumentPosition} the response
	// is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
	// or a Thenable that resolves to such.
	//
	// The request can delay the computation of the {@link CompletionItem.detail `detail`}
	// and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
	// request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
	// `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
	HandleTextDocumentCompletion(
		context.Context,
		CompletionParams,
	) (*OneOf2[[]CompletionItem, CompletionList], error)
}

// TextDocumentCompletionRoute returns a route for the "textDocument/completion" request.
func TextDocumentCompletionRoute(h TextDocumentCompletionHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/completion",
		h.HandleTextDocumentCompletion,
	)
}

// TextDocumentDeclarationHandler handles "textDocument/declaration" requests.
type TextDocumentDeclarationHandler interface {
	// A request to resolve the type definition locations of a symbol at a given text
	// document position. The request's parameter is of type [TextDocumentPositionParams]
	// (#TextDocumentPositionParams) the response is of type {@link Declaration}
	// or a typed array of {@link DeclarationLink} or a Thenable that resolves
	// to such.
	HandleTextDocumentDeclaration(
		context.Context,
		DeclarationParams,
	) (*OneOf2[Declaration, []DeclarationLink], error)
}

// TextDocumentDeclarationRoute returns a route for the "textDocument/declaration" request.
func TextDocumentDeclarationRoute(h TextDocumentDeclarationHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/declaration",
		h.HandleTextDocumentDeclaration,
	)
}

// TextDocumentDefinitionHandler handles "textDocument/definition" requests.
type TextDocumentDefinitionHandler interface {
	// A request to resolve the definition location of a symbol at a given text
	// document position. The request's parameter is of type [TextDocumentPosition]
	// (#TextDocumentPosition) the response is of either type {@link Definition}
	// or a typed array of {@link DefinitionLink} or a Thenable that resolves
	// to such.
	HandleTextDocumentDefinition(
		context.Context,
		DefinitionParams,
	) (*OneOf2[Definition, []DefinitionLink], error)
}

// TextDocumentDefinitionRoute returns a route for the "textDocument/definition" request.
func TextDocumentDefinitionRoute(h TextDocumentDefinitionHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/definition",
		h.HandleTextDocumentDefinition,
	)
}

// TextDocumentDiagnosticHandler handles "textDocument/diagnostic" requests.
type TextDocumentDiagnosticHandler interface {
	// The document diagnostic request definition.
	//
	// @since 3.17.0
	HandleTextDocumentDiagnostic(
		context.Context,
		DocumentDiagnosticParams,
	) (DocumentDiagnosticReport, error)
}

// TextDocumentDiagnosticRoute returns a route for the "textDocument/diagnostic" request.
func TextDocumentDiagnosticRoute(h TextDocumentDiagnosticHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/diagnostic",
		h.HandleTextDocumentDiagnostic,
	)
}

// TextDocumentDocumentColorHandler handles "textDocument/documentColor" requests.
type TextDocumentDocumentColorHandler interface {
	// A request to list all color symbols found in a given text document. The request's
	// parameter is of type {@link DocumentColorParams} the
	// response is of type {@link ColorInformation ColorInformation[]} or a Thenable
	// that resolves to such.
	HandleTextDocumentDocumentColor(
		context.Context,
		DocumentColorParams,
	) ([]ColorInformation, error)
}

// TextDocumentDocumentColorRoute returns a route for the "textDocument/documentColor" request.
func TextDocumentDocumentColorRoute(h TextDocumentDocumentColorHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/documentColor",
		h.HandleTextDocumentDocumentColor,
	)
}

// TextDocumentDocumentHighlightHandler handles "textDocument/documentHighlight" requests.
type TextDocumentDocumentHighlightHandler interface {
	// Request to resolve a {@link DocumentHighlight} for a given
	// text document position. The request's parameter is of type [TextDocumentPosition]
	// (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
	// (#DocumentHighlight) or a Thenable that resolves to such.
	HandleTextDocumentDocumentHighlight(
		context.Context,
		DocumentHighlightParams,
	) ([]DocumentHighlight, error)
}

// TextDocumentDocumentHighlightRoute returns a route for the "textDocument/documentHighlight" request.
func TextDocumentDocumentHighlightRoute(h TextDocumentDocumentHighlightHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/documentHighlight",
		h.HandleTextDocumentDocumentHighlight,
	)
}

// TextDocumentDocumentLinkHandler handles "textDocument/documentLink" requests.
type TextDocumentDocumentLinkHandler interface {
	// A request to provide document links
	HandleTextDocumentDocumentLink(
		context.Context,
		DocumentLinkParams,
	) ([]DocumentLink, error)
}

// TextDocumentDocumentLinkRoute returns a route for the "textDocument/documentLink" request.
func TextDocumentDocumentLinkRoute(h TextDocumentDocumentLinkHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/documentLink",
		h.HandleTextDocumentDocumentLink,
	)
}

// TextDocumentDocumentSymbolHandler handles "textDocument/documentSymbol" requests.
type TextDocumentDocumentSymbolHandler interface {
	// A request to list all symbols found in a given text document. The request's
	// parameter is of type {@link TextDocumentIdentifier} the
	// response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
	// that resolves to such.
	HandleTextDocumentDocumentSymbol(
		context.Context,
		DocumentSymbolParams,
	) (*OneOf2[[]SymbolInformation, []DocumentSymbol], error)
}

// TextDocumentDocumentSymbolRoute returns a route for the "textDocument/documentSymbol" request.
func TextDocumentDocumentSymbolRoute(h TextDocumentDocumentSymbolHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/documentSymbol",
		h.HandleTextDocumentDocumentSymbol,
	)
}

// TextDocumentFoldingRangeHandler handles "textDocument/foldingRange" requests.
type TextDocumentFoldingRangeHandler interface {
	// A request to provide folding ranges in a document. The request's
	// parameter is of type {@link FoldingRangeParams}, the
	// response is of type {@link FoldingRangeList} or a Thenable
	// that resolves to such.
	HandleTextDocumentFoldingRange(
		context.Context,
		FoldingRangeParams,
	) ([]FoldingRange, error)
}

// TextDocumentFoldingRangeRoute returns a route for the "textDocument/foldingRange" request.
func TextDocumentFoldingRangeRoute(h TextDocumentFoldingRangeHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/foldingRange",
		h.HandleTextDocumentFoldingRange,
	)
}

// TextDocumentFormattingHandler handles "textDocument/formatting" requests.
type TextDocumentFormattingHandler interface {
	// A request to to format a whole document.
	HandleTextDocumentFormatting(
		context.Context,
		DocumentFormattingParams,
	) ([]TextEdit, error)
}

// TextDocumentFormattingRoute returns a route for the "textDocument/formatting" request.
func TextDocumentFormattingRoute(h TextDocumentFormattingHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/formatting",
		h.HandleTextDocumentFormatting,
	)
}

// TextDocumentHoverHandler handles "textDocument/hover" requests.
type TextDocumentHoverHandler interface {
	// Request to request hover information at a given text document position. The request's
	// parameter is of type {@link TextDocumentPosition} the response is of
	// type {@link Hover} or a Thenable that resolves to such.
	HandleTextDocumentHover(
		context.Context,
		HoverParams,
	) (*Hover, error)
}

// TextDocumentHoverRoute returns a route for the "textDocument/hover" request.
func TextDocumentHoverRoute(h TextDocumentHoverHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/hover",
		h.HandleTextDocumentHover,
	)
}

// TextDocumentImplementationHandler handles "textDocument/implementation" requests.
type TextDocumentImplementationHandler interface {
	// A request to resolve the implementation locations of a symbol at a given text
	// document position. The request's parameter is of type [TextDocumentPositionParams]
	// (#TextDocumentPositionParams) the response is of type {@link Definition} or a
	// Thenable that resolves to such.
	HandleTextDocumentImplementation(
		context.Context,
		ImplementationParams,
	) (*OneOf2[Definition, []DefinitionLink], error)
}

// TextDocumentImplementationRoute returns a route for the "textDocument/implementation" request.
func TextDocumentImplementationRoute(h TextDocumentImplementationHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/implementation",
		h.HandleTextDocumentImplementation,
	)
}

// TextDocumentInlayHintHandler handles "textDocument/inlayHint" requests.
type TextDocumentInlayHintHandler interface {
	// A request to provide inlay hints in a document. The request's parameter is of
	// type {@link InlayHintsParams}, the response is of type
	// {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
	//
	// @since 3.17.0
	HandleTextDocumentInlayHint(
		context.Context,
		InlayHintParams,
	) ([]InlayHint, error)
}

// TextDocumentInlayHintRoute returns a route for the "textDocument/inlayHint" request.
func TextDocumentInlayHintRoute(h TextDocumentInlayHintHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/inlayHint",
		h.HandleTextDocumentInlayHint,
	)
}

// TextDocumentInlineValueHandler handles "textDocument/inlineValue" requests.
type TextDocumentInlineValueHandler interface {
	// A request to provide inline values in a document. The request's parameter is of
	// type {@link InlineValueParams}, the response is of type
	// {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
	//
	// @since 3.17.0
	HandleTextDocumentInlineValue(
		context.Context,
		InlineValueParams,
	) ([]InlineValue, error)
}

// TextDocumentInlineValueRoute returns a route for the "textDocument/inlineValue" request.
func TextDocumentInlineValueRoute(h TextDocumentInlineValueHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/inlineValue",
		h.HandleTextDocumentInlineValue,
	)
}

// TextDocumentLinkedEditingRangeHandler handles "textDocument/linkedEditingRange" requests.
type TextDocumentLinkedEditingRangeHandler interface {
	// A request to provide ranges that can be edited together.
	//
	// @since 3.16.0
	HandleTextDocumentLinkedEditingRange(
		context.Context,
		LinkedEditingRangeParams,
	) (*LinkedEditingRanges, error)
}

// TextDocumentLinkedEditingRangeRoute returns a route for the "textDocument/linkedEditingRange" request.
func TextDocumentLinkedEditingRangeRoute(h TextDocumentLinkedEditingRangeHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/linkedEditingRange",
		h.HandleTextDocumentLinkedEditingRange,
	)
}

// TextDocumentMonikerHandler handles "textDocument/moniker" requests.
type TextDocumentMonikerHandler interface {
	// A request to get the moniker of a symbol at a given text document position.
	// The request parameter is of type {@link TextDocumentPositionParams}.
	// The response is of type {@link Moniker Moniker[]} or `null`.
	HandleTextDocumentMoniker(
		context.Context,
		MonikerParams,
	) ([]Moniker, error)
}

// TextDocumentMonikerRoute returns a route for the "textDocument/moniker" request.
func TextDocumentMonikerRoute(h TextDocumentMonikerHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/moniker",
		h.HandleTextDocumentMoniker,
	)
}

// TextDocumentOnTypeFormattingHandler handles "textDocument/onTypeFormatting" requests.
type TextDocumentOnTypeFormattingHandler interface {
	// A request to format a document on type.
	HandleTextDocumentOnTypeFormatting(
		context.Context,
		DocumentOnTypeFormattingParams,
	) ([]TextEdit, error)
}

// TextDocumentOnTypeFormattingRoute returns a route for the "textDocument/onTypeFormatting" request.
func TextDocumentOnTypeFormattingRoute(h TextDocumentOnTypeFormattingHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/onTypeFormatting",
		h.HandleTextDocumentOnTypeFormatting,
	)
}

// TextDocumentPrepareCallHierarchyHandler handles "textDocument/prepareCallHierarchy" requests.
type TextDocumentPrepareCallHierarchyHandler interface {
	// A request to result a `CallHierarchyItem` in a document at a given position.
	// Can be used as an input to an incoming or outgoing call hierarchy.
	//
	// @since 3.16.0
	HandleTextDocumentPrepareCallHierarchy(
		context.Context,
		CallHierarchyPrepareParams,
	) ([]CallHierarchyItem, error)
}

// TextDocumentPrepareCallHierarchyRoute returns a route for the "textDocument/prepareCallHierarchy" request.
func TextDocumentPrepareCallHierarchyRoute(h TextDocumentPrepareCallHierarchyHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/prepareCallHierarchy",
		h.HandleTextDocumentPrepareCallHierarchy,
	)
}

// TextDocumentPrepareRenameHandler handles "textDocument/prepareRename" requests.
type TextDocumentPrepareRenameHandler interface {
	// A request to test and perform the setup necessary for a rename.
	//
	// @since 3.16 - support for default behavior
	HandleTextDocumentPrepareRename(
		context.Context,
		PrepareRenameParams,
	) (*PrepareRenameResult, error)
}

// TextDocumentPrepareRenameRoute returns a route for the "textDocument/prepareRename" request.
func TextDocumentPrepareRenameRoute(h TextDocumentPrepareRenameHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/prepareRename",
		h.HandleTextDocumentPrepareRename,
	)
}

// TextDocumentPrepareTypeHierarchyHandler handles "textDocument/prepareTypeHierarchy" requests.
type TextDocumentPrepareTypeHierarchyHandler interface {
	// A request to result a `TypeHierarchyItem` in a document at a given position.
	// Can be used as an input to a subtypes or supertypes type hierarchy.
	//
	// @since 3.17.0
	HandleTextDocumentPrepareTypeHierarchy(
		context.Context,
		TypeHierarchyPrepareParams,
	) ([]TypeHierarchyItem, error)
}

// TextDocumentPrepareTypeHierarchyRoute returns a route for the "textDocument/prepareTypeHierarchy" request.
func TextDocumentPrepareTypeHierarchyRoute(h TextDocumentPrepareTypeHierarchyHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/prepareTypeHierarchy",
		h.HandleTextDocumentPrepareTypeHierarchy,
	)
}

// TextDocumentRangeFormattingHandler handles "textDocument/rangeFormatting" requests.
type TextDocumentRangeFormattingHandler interface {
	// A request to to format a range in a document.
	HandleTextDocumentRangeFormatting(
		context.Context,
		DocumentRangeFormattingParams,
	) ([]TextEdit, error)
}

// TextDocumentRangeFormattingRoute returns a route for the "textDocument/rangeFormatting" request.
func TextDocumentRangeFormattingRoute(h TextDocumentRangeFormattingHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/rangeFormatting",
		h.HandleTextDocumentRangeFormatting,
	)
}

// TextDocumentReferencesHandler handles "textDocument/references" requests.
type TextDocumentReferencesHandler interface {
	// A request to resolve project-wide references for the symbol denoted
	// by the given text document position. The request's parameter is of
	// type {@link ReferenceParams} the response is of type
	// {@link Location Location[]} or a Thenable that resolves to such.
	HandleTextDocumentReferences(
		context.Context,
		ReferenceParams,
	) ([]Location, error)
}

// TextDocumentReferencesRoute returns a route for the "textDocument/references" request.
func TextDocumentReferencesRoute(h TextDocumentReferencesHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/references",
		h.HandleTextDocumentReferences,
	)
}

// TextDocumentRenameHandler handles "textDocument/rename" requests.
type TextDocumentRenameHandler interface {
	// A request to rename a symbol.
	HandleTextDocumentRename(
		context.Context,
		RenameParams,
	) (*WorkspaceEdit, error)
}

// TextDocumentRenameRoute returns a route for the "textDocument/rename" request.
func TextDocumentRenameRoute(h TextDocumentRenameHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/rename",
		h.HandleTextDocumentRename,
	)
}

// TextDocumentSelectionRangeHandler handles "textDocument/selectionRange" requests.
type TextDocumentSelectionRangeHandler interface {
	// A request to provide selection ranges in a document. The request's
	// parameter is of type {@link SelectionRangeParams}, the
	// response is of type {@link SelectionRange SelectionRange[]} or a Thenable
	// that resolves to such.
	HandleTextDocumentSelectionRange(
		context.Context,
		SelectionRangeParams,
	) ([]SelectionRange, error)
}

// TextDocumentSelectionRangeRoute returns a route for the "textDocument/selectionRange" request.
func TextDocumentSelectionRangeRoute(h TextDocumentSelectionRangeHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/selectionRange",
		h.HandleTextDocumentSelectionRange,
	)
}

// TextDocumentSemanticTokensFullHandler handles "textDocument/semanticTokens/full" requests.
type TextDocumentSemanticTokensFullHandler interface {
	// @since 3.16.0
	HandleTextDocumentSemanticTokensFull(
		context.Context,
		SemanticTokensParams,
	) (*SemanticTokens, error)
}

// TextDocumentSemanticTokensFullRoute returns a route for the "textDocument/semanticTokens/full" request.
func TextDocumentSemanticTokensFullRoute(h TextDocumentSemanticTokensFullHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/semanticTokens/full",
		h.HandleTextDocumentSemanticTokensFull,
	)
}

// TextDocumentSemanticTokensFullDeltaHandler handles "textDocument/semanticTokens/full/delta" requests.
type TextDocumentSemanticTokensFullDeltaHandler interface {
	// @since 3.16.0
	HandleTextDocumentSemanticTokensFullDelta(
		context.Context,
		SemanticTokensDeltaParams,
	) (*OneOf2[SemanticTokens, SemanticTokensDelta], error)
}

// TextDocumentSemanticTokensFullDeltaRoute returns a route for the "textDocument/semanticTokens/full/delta" request.
func TextDocumentSemanticTokensFullDeltaRoute(h TextDocumentSemanticTokensFullDeltaHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/semanticTokens/full/delta",
		h.HandleTextDocumentSemanticTokensFullDelta,
	)
}

// TextDocumentSemanticTokensRangeHandler handles "textDocument/semanticTokens/range" requests.
type TextDocumentSemanticTokensRangeHandler interface {
	// @since 3.16.0
	HandleTextDocumentSemanticTokensRange(
		context.Context,
		SemanticTokensRangeParams,
	) (*SemanticTokens, error)
}

// TextDocumentSemanticTokensRangeRoute returns a route for the "textDocument/semanticTokens/range" request.
func TextDocumentSemanticTokensRangeRoute(h TextDocumentSemanticTokensRangeHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/semanticTokens/range",
		h.HandleTextDocumentSemanticTokensRange,
	)
}

// TextDocumentSignatureHelpHandler handles "textDocument/signatureHelp" requests.
type TextDocumentSignatureHelpHandler interface {
	HandleTextDocumentSignatureHelp(
		context.Context,
		SignatureHelpParams,
	) (*SignatureHelp, error)
}

// TextDocumentSignatureHelpRoute returns a route for the "textDocument/signatureHelp" request.
func TextDocumentSignatureHelpRoute(h TextDocumentSignatureHelpHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/signatureHelp",
		h.HandleTextDocumentSignatureHelp,
	)
}

// TextDocumentTypeDefinitionHandler handles "textDocument/typeDefinition" requests.
type TextDocumentTypeDefinitionHandler interface {
	// A request to resolve the type definition locations of a symbol at a given text
	// document position. The request's parameter is of type [TextDocumentPositionParams]
	// (#TextDocumentPositionParams) the response is of type {@link Definition} or a
	// Thenable that resolves to such.
	HandleTextDocumentTypeDefinition(
		context.Context,
		TypeDefinitionParams,
	) (*OneOf2[Definition, []DefinitionLink], error)
}

// TextDocumentTypeDefinitionRoute returns a route for the "textDocument/typeDefinition" request.
func TextDocumentTypeDefinitionRoute(h TextDocumentTypeDefinitionHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/typeDefinition",
		h.HandleTextDocumentTypeDefinition,
	)
}

// TextDocumentWillSaveWaitUntilHandler handles "textDocument/willSaveWaitUntil" requests.
type TextDocumentWillSaveWaitUntilHandler interface {
	// A document will save request is sent from the client to the server before
	// the document is actually saved. The request can return an array of TextEdits
	// which will be applied to the text document before it is saved. Please note that
	// clients might drop results if computing the text edits took too long or if a
	// server constantly fails on this request. This is done to keep the save fast and
	// reliable.
	HandleTextDocumentWillSaveWaitUntil(
		context.Context,
		WillSaveTextDocumentParams,
	) ([]TextEdit, error)
}

// TextDocumentWillSaveWaitUntilRoute returns a route for the "textDocument/willSaveWaitUntil" request.
func TextDocumentWillSaveWaitUntilRoute(h TextDocumentWillSaveWaitUntilHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/willSaveWaitUntil",
		h.HandleTextDocumentWillSaveWaitUntil,
	)
}

// TypeHierarchySubtypesHandler handles "typeHierarchy/subtypes" requests.
type TypeHierarchySubtypesHandler interface {
	// A request to resolve the subtypes for a given `TypeHierarchyItem`.
	//
	// @since 3.17.0
	HandleTypeHierarchySubtypes(
		context.Context,
		TypeHierarchySubtypesParams,
	) ([]TypeHierarchyItem, error)
}

// TypeHierarchySubtypesRoute returns a route for the "typeHierarchy/subtypes" request.
func TypeHierarchySubtypesRoute(h TypeHierarchySubtypesHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"typeHierarchy/subtypes",
		h.HandleTypeHierarchySubtypes,
	)
}

// TypeHierarchySupertypesHandler handles "typeHierarchy/supertypes" requests.
type TypeHierarchySupertypesHandler interface {
	// A request to resolve the supertypes for a given `TypeHierarchyItem`.
	//
	// @since 3.17.0
	HandleTypeHierarchySupertypes(
		context.Context,
		TypeHierarchySupertypesParams,
	) ([]TypeHierarchyItem, error)
}

// TypeHierarchySupertypesRoute returns a route for the "typeHierarchy/supertypes" request.
func TypeHierarchySupertypesRoute(h TypeHierarchySupertypesHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"typeHierarchy/supertypes",
		h.HandleTypeHierarchySupertypes,
	)
}

// WorkspaceDiagnosticHandler handles "workspace/diagnostic" requests.
type WorkspaceDiagnosticHandler interface {
	// The workspace diagnostic request definition.
	//
	// @since 3.17.0
	HandleWorkspaceDiagnostic(
		context.Context,
		WorkspaceDiagnosticParams,
	) (WorkspaceDiagnosticReport, error)
}

// WorkspaceDiagnosticRoute returns a route for the "workspace/diagnostic" request.
func WorkspaceDiagnosticRoute(h WorkspaceDiagnosticHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/diagnostic",
		h.HandleWorkspaceDiagnostic,
	)
}

// WorkspaceExecuteCommandHandler handles "workspace/executeCommand" requests.
type WorkspaceExecuteCommandHandler interface {
	// A request send from the client to the server to execute a command. The request might return
	// a workspace edit which the client will apply to the workspace.
	HandleWorkspaceExecuteCommand(
		context.Context,
		ExecuteCommandParams,
	) (any, error)
}

// WorkspaceExecuteCommandRoute returns a route for the "workspace/executeCommand" request.
func WorkspaceExecuteCommandRoute(h WorkspaceExecuteCommandHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/executeCommand",
		h.HandleWorkspaceExecuteCommand,
	)
}

// WorkspaceSymbolHandler handles "workspace/symbol" requests.
type WorkspaceSymbolHandler interface {
	// A request to list project-wide symbols matching the query string given
	// by the {@link WorkspaceSymbolParams}. The response is
	// of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
	// resolves to such.
	//
	// @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
	//
	//	need to advertise support for WorkspaceSymbols via the client capability
	//	`workspace.symbol.resolveSupport`.
	HandleWorkspaceSymbol(
		context.Context,
		WorkspaceSymbolParams,
	) (*OneOf2[[]SymbolInformation, []WorkspaceSymbol], error)
}

// WorkspaceSymbolRoute returns a route for the "workspace/symbol" request.
func WorkspaceSymbolRoute(h WorkspaceSymbolHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/symbol",
		h.HandleWorkspaceSymbol,
	)
}

// WorkspaceWillCreateFilesHandler handles "workspace/willCreateFiles" requests.
type WorkspaceWillCreateFilesHandler interface {
	// The will create files request is sent from the client to the server before files are actually
	// created as long as the creation is triggered from within the client.
	//
	// The request can return a `WorkspaceEdit` which will be applied to workspace before the
	// files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
	// to be created.
	//
	// @since 3.16.0
	HandleWorkspaceWillCreateFiles(
		context.Context,
		CreateFilesParams,
	) (*WorkspaceEdit, error)
}

// WorkspaceWillCreateFilesRoute returns a route for the "workspace/willCreateFiles" request.
func WorkspaceWillCreateFilesRoute(h WorkspaceWillCreateFilesHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/willCreateFiles",
		h.HandleWorkspaceWillCreateFiles,
	)
}

// WorkspaceWillDeleteFilesHandler handles "workspace/willDeleteFiles" requests.
type WorkspaceWillDeleteFilesHandler interface {
	// The did delete files notification is sent from the client to the server when
	// files were deleted from within the client.
	//
	// @since 3.16.0
	HandleWorkspaceWillDeleteFiles(
		context.Context,
		DeleteFilesParams,
	) (*WorkspaceEdit, error)
}

// WorkspaceWillDeleteFilesRoute returns a route for the "workspace/willDeleteFiles" request.
func WorkspaceWillDeleteFilesRoute(h WorkspaceWillDeleteFilesHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/willDeleteFiles",
		h.HandleWorkspaceWillDeleteFiles,
	)
}

// WorkspaceWillRenameFilesHandler handles "workspace/willRenameFiles" requests.
type WorkspaceWillRenameFilesHandler interface {
	// The will rename files request is sent from the client to the server before files are actually
	// renamed as long as the rename is triggered from within the client.
	//
	// @since 3.16.0
	HandleWorkspaceWillRenameFiles(
		context.Context,
		RenameFilesParams,
	) (*WorkspaceEdit, error)
}

// WorkspaceWillRenameFilesRoute returns a route for the "workspace/willRenameFiles" request.
func WorkspaceWillRenameFilesRoute(h WorkspaceWillRenameFilesHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/willRenameFiles",
		h.HandleWorkspaceWillRenameFiles,
	)
}

// WorkspaceSymbolResolveHandler handles "workspaceSymbol/resolve" requests.
type WorkspaceSymbolResolveHandler interface {
	// A request to resolve the range inside the workspace
	// symbol's location.
	//
	// @since 3.17.0
	HandleWorkspaceSymbolResolve(
		context.Context,
		WorkspaceSymbol,
	) (WorkspaceSymbol, error)
}

// WorkspaceSymbolResolveRoute returns a route for the "workspaceSymbol/resolve" request.
func WorkspaceSymbolResolveRoute(h WorkspaceSymbolResolveHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspaceSymbol/resolve",
		h.HandleWorkspaceSymbolResolve,
	)
}

// ---------------------------------------------------------------------------------------------------------------------
// NOTIFICATIONS
// ---------------------------------------------------------------------------------------------------------------------

// WorkspaceDidChangeWorkspaceFoldersHandler handles "workspace/didChangeWorkspaceFolders" notifications.
type WorkspaceDidChangeWorkspaceFoldersHandler interface {
	// The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
	// folder configuration changes.
	HandleWorkspaceDidChangeWorkspaceFolders(
		context.Context,
		DidChangeWorkspaceFoldersParams,
	) error
}

// WorkspaceDidChangeWorkspaceFoldersRoute returns a route for the "workspace/didChangeWorkspaceFolders" notification.
func WorkspaceDidChangeWorkspaceFoldersRoute(h WorkspaceDidChangeWorkspaceFoldersHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/didChangeWorkspaceFolders",
		func(ctx context.Context, p DidChangeWorkspaceFoldersParams) (any, error) {
			return nil, h.HandleWorkspaceDidChangeWorkspaceFolders(ctx, p)
		},
	)
}

// WindowWorkDoneProgressCancelHandler handles "window/workDoneProgress/cancel" notifications.
type WindowWorkDoneProgressCancelHandler interface {
	// The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
	// initiated on the server side.
	HandleWindowWorkDoneProgressCancel(
		context.Context,
		WorkDoneProgressCancelParams,
	) error
}

// WindowWorkDoneProgressCancelRoute returns a route for the "window/workDoneProgress/cancel" notification.
func WindowWorkDoneProgressCancelRoute(h WindowWorkDoneProgressCancelHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"window/workDoneProgress/cancel",
		func(ctx context.Context, p WorkDoneProgressCancelParams) (any, error) {
			return nil, h.HandleWindowWorkDoneProgressCancel(ctx, p)
		},
	)
}

// WorkspaceDidCreateFilesHandler handles "workspace/didCreateFiles" notifications.
type WorkspaceDidCreateFilesHandler interface {
	// The did create files notification is sent from the client to the server when
	// files were created from within the client.
	//
	// @since 3.16.0
	HandleWorkspaceDidCreateFiles(
		context.Context,
		CreateFilesParams,
	) error
}

// WorkspaceDidCreateFilesRoute returns a route for the "workspace/didCreateFiles" notification.
func WorkspaceDidCreateFilesRoute(h WorkspaceDidCreateFilesHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/didCreateFiles",
		func(ctx context.Context, p CreateFilesParams) (any, error) {
			return nil, h.HandleWorkspaceDidCreateFiles(ctx, p)
		},
	)
}

// WorkspaceDidRenameFilesHandler handles "workspace/didRenameFiles" notifications.
type WorkspaceDidRenameFilesHandler interface {
	// The did rename files notification is sent from the client to the server when
	// files were renamed from within the client.
	//
	// @since 3.16.0
	HandleWorkspaceDidRenameFiles(
		context.Context,
		RenameFilesParams,
	) error
}

// WorkspaceDidRenameFilesRoute returns a route for the "workspace/didRenameFiles" notification.
func WorkspaceDidRenameFilesRoute(h WorkspaceDidRenameFilesHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/didRenameFiles",
		func(ctx context.Context, p RenameFilesParams) (any, error) {
			return nil, h.HandleWorkspaceDidRenameFiles(ctx, p)
		},
	)
}

// WorkspaceDidDeleteFilesHandler handles "workspace/didDeleteFiles" notifications.
type WorkspaceDidDeleteFilesHandler interface {
	// The will delete files request is sent from the client to the server before files are actually
	// deleted as long as the deletion is triggered from within the client.
	//
	// @since 3.16.0
	HandleWorkspaceDidDeleteFiles(
		context.Context,
		DeleteFilesParams,
	) error
}

// WorkspaceDidDeleteFilesRoute returns a route for the "workspace/didDeleteFiles" notification.
func WorkspaceDidDeleteFilesRoute(h WorkspaceDidDeleteFilesHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/didDeleteFiles",
		func(ctx context.Context, p DeleteFilesParams) (any, error) {
			return nil, h.HandleWorkspaceDidDeleteFiles(ctx, p)
		},
	)
}

// NotebookDocumentDidOpenHandler handles "notebookDocument/didOpen" notifications.
type NotebookDocumentDidOpenHandler interface {
	// A notification sent when a notebook opens.
	//
	// @since 3.17.0
	HandleNotebookDocumentDidOpen(
		context.Context,
		DidOpenNotebookDocumentParams,
	) error
}

// NotebookDocumentDidOpenRoute returns a route for the "notebookDocument/didOpen" notification.
func NotebookDocumentDidOpenRoute(h NotebookDocumentDidOpenHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"notebookDocument/didOpen",
		func(ctx context.Context, p DidOpenNotebookDocumentParams) (any, error) {
			return nil, h.HandleNotebookDocumentDidOpen(ctx, p)
		},
	)
}

// NotebookDocumentDidChangeHandler handles "notebookDocument/didChange" notifications.
type NotebookDocumentDidChangeHandler interface {
	HandleNotebookDocumentDidChange(
		context.Context,
		DidChangeNotebookDocumentParams,
	) error
}

// NotebookDocumentDidChangeRoute returns a route for the "notebookDocument/didChange" notification.
func NotebookDocumentDidChangeRoute(h NotebookDocumentDidChangeHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"notebookDocument/didChange",
		func(ctx context.Context, p DidChangeNotebookDocumentParams) (any, error) {
			return nil, h.HandleNotebookDocumentDidChange(ctx, p)
		},
	)
}

// NotebookDocumentDidSaveHandler handles "notebookDocument/didSave" notifications.
type NotebookDocumentDidSaveHandler interface {
	// A notification sent when a notebook document is saved.
	//
	// @since 3.17.0
	HandleNotebookDocumentDidSave(
		context.Context,
		DidSaveNotebookDocumentParams,
	) error
}

// NotebookDocumentDidSaveRoute returns a route for the "notebookDocument/didSave" notification.
func NotebookDocumentDidSaveRoute(h NotebookDocumentDidSaveHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"notebookDocument/didSave",
		func(ctx context.Context, p DidSaveNotebookDocumentParams) (any, error) {
			return nil, h.HandleNotebookDocumentDidSave(ctx, p)
		},
	)
}

// NotebookDocumentDidCloseHandler handles "notebookDocument/didClose" notifications.
type NotebookDocumentDidCloseHandler interface {
	// A notification sent when a notebook closes.
	//
	// @since 3.17.0
	HandleNotebookDocumentDidClose(
		context.Context,
		DidCloseNotebookDocumentParams,
	) error
}

// NotebookDocumentDidCloseRoute returns a route for the "notebookDocument/didClose" notification.
func NotebookDocumentDidCloseRoute(h NotebookDocumentDidCloseHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"notebookDocument/didClose",
		func(ctx context.Context, p DidCloseNotebookDocumentParams) (any, error) {
			return nil, h.HandleNotebookDocumentDidClose(ctx, p)
		},
	)
}

// InitializedHandler handles "initialized" notifications.
type InitializedHandler interface {
	// The initialized notification is sent from the client to the
	// server after the client is fully initialized and the server
	// is allowed to send requests from the server to the client.
	HandleInitialized(
		context.Context,
		InitializedParams,
	) error
}

// InitializedRoute returns a route for the "initialized" notification.
func InitializedRoute(h InitializedHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"initialized",
		func(ctx context.Context, p InitializedParams) (any, error) {
			return nil, h.HandleInitialized(ctx, p)
		},
	)
}

// ExitHandler handles "exit" notifications.
type ExitHandler interface {
	// The exit event is sent from the client to the server to
	// ask the server to exit its process.
	HandleExit(
		context.Context,
	) error
}

// ExitRoute returns a route for the "exit" notification.
func ExitRoute(h ExitHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"exit",
		func(ctx context.Context, _ struct{}) (any, error) {
			return nil, h.HandleExit(ctx)
		},
	)
}

// WorkspaceDidChangeConfigurationHandler handles "workspace/didChangeConfiguration" notifications.
type WorkspaceDidChangeConfigurationHandler interface {
	// The configuration change notification is sent from the client to the server
	// when the client's configuration has changed. The notification contains
	// the changed configuration as defined by the language client.
	HandleWorkspaceDidChangeConfiguration(
		context.Context,
		DidChangeConfigurationParams,
	) error
}

// WorkspaceDidChangeConfigurationRoute returns a route for the "workspace/didChangeConfiguration" notification.
func WorkspaceDidChangeConfigurationRoute(h WorkspaceDidChangeConfigurationHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/didChangeConfiguration",
		func(ctx context.Context, p DidChangeConfigurationParams) (any, error) {
			return nil, h.HandleWorkspaceDidChangeConfiguration(ctx, p)
		},
	)
}

// TextDocumentDidOpenHandler handles "textDocument/didOpen" notifications.
type TextDocumentDidOpenHandler interface {
	// The document open notification is sent from the client to the server to signal
	// newly opened text documents. The document's truth is now managed by the client
	// and the server must not try to read the document's truth using the document's
	// uri. Open in this sense means it is managed by the client. It doesn't necessarily
	// mean that its content is presented in an editor. An open notification must not
	// be sent more than once without a corresponding close notification send before.
	// This means open and close notification must be balanced and the max open count
	// is one.
	HandleTextDocumentDidOpen(
		context.Context,
		DidOpenTextDocumentParams,
	) error
}

// TextDocumentDidOpenRoute returns a route for the "textDocument/didOpen" notification.
func TextDocumentDidOpenRoute(h TextDocumentDidOpenHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/didOpen",
		func(ctx context.Context, p DidOpenTextDocumentParams) (any, error) {
			return nil, h.HandleTextDocumentDidOpen(ctx, p)
		},
	)
}

// TextDocumentDidChangeHandler handles "textDocument/didChange" notifications.
type TextDocumentDidChangeHandler interface {
	// The document change notification is sent from the client to the server to signal
	// changes to a text document.
	HandleTextDocumentDidChange(
		context.Context,
		DidChangeTextDocumentParams,
	) error
}

// TextDocumentDidChangeRoute returns a route for the "textDocument/didChange" notification.
func TextDocumentDidChangeRoute(h TextDocumentDidChangeHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/didChange",
		func(ctx context.Context, p DidChangeTextDocumentParams) (any, error) {
			return nil, h.HandleTextDocumentDidChange(ctx, p)
		},
	)
}

// TextDocumentDidCloseHandler handles "textDocument/didClose" notifications.
type TextDocumentDidCloseHandler interface {
	// The document close notification is sent from the client to the server when
	// the document got closed in the client. The document's truth now exists where
	// the document's uri points to (e.g. if the document's uri is a file uri the
	// truth now exists on disk). As with the open notification the close notification
	// is about managing the document's content. Receiving a close notification
	// doesn't mean that the document was open in an editor before. A close
	// notification requires a previous open notification to be sent.
	HandleTextDocumentDidClose(
		context.Context,
		DidCloseTextDocumentParams,
	) error
}

// TextDocumentDidCloseRoute returns a route for the "textDocument/didClose" notification.
func TextDocumentDidCloseRoute(h TextDocumentDidCloseHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/didClose",
		func(ctx context.Context, p DidCloseTextDocumentParams) (any, error) {
			return nil, h.HandleTextDocumentDidClose(ctx, p)
		},
	)
}

// TextDocumentDidSaveHandler handles "textDocument/didSave" notifications.
type TextDocumentDidSaveHandler interface {
	// The document save notification is sent from the client to the server when
	// the document got saved in the client.
	HandleTextDocumentDidSave(
		context.Context,
		DidSaveTextDocumentParams,
	) error
}

// TextDocumentDidSaveRoute returns a route for the "textDocument/didSave" notification.
func TextDocumentDidSaveRoute(h TextDocumentDidSaveHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/didSave",
		func(ctx context.Context, p DidSaveTextDocumentParams) (any, error) {
			return nil, h.HandleTextDocumentDidSave(ctx, p)
		},
	)
}

// TextDocumentWillSaveHandler handles "textDocument/willSave" notifications.
type TextDocumentWillSaveHandler interface {
	// A document will save notification is sent from the client to the server before
	// the document is actually saved.
	HandleTextDocumentWillSave(
		context.Context,
		WillSaveTextDocumentParams,
	) error
}

// TextDocumentWillSaveRoute returns a route for the "textDocument/willSave" notification.
func TextDocumentWillSaveRoute(h TextDocumentWillSaveHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"textDocument/willSave",
		func(ctx context.Context, p WillSaveTextDocumentParams) (any, error) {
			return nil, h.HandleTextDocumentWillSave(ctx, p)
		},
	)
}

// WorkspaceDidChangeWatchedFilesHandler handles "workspace/didChangeWatchedFiles" notifications.
type WorkspaceDidChangeWatchedFilesHandler interface {
	// The watched files notification is sent from the client to the server when
	// the client detects changes to file watched by the language client.
	HandleWorkspaceDidChangeWatchedFiles(
		context.Context,
		DidChangeWatchedFilesParams,
	) error
}

// WorkspaceDidChangeWatchedFilesRoute returns a route for the "workspace/didChangeWatchedFiles" notification.
func WorkspaceDidChangeWatchedFilesRoute(h WorkspaceDidChangeWatchedFilesHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"workspace/didChangeWatchedFiles",
		func(ctx context.Context, p DidChangeWatchedFilesParams) (any, error) {
			return nil, h.HandleWorkspaceDidChangeWatchedFiles(ctx, p)
		},
	)
}

// SetTraceHandler handles "$/setTrace" notifications.
type SetTraceHandler interface {
	HandleSetTrace(
		context.Context,
		SetTraceParams,
	) error
}

// SetTraceRoute returns a route for the "$/setTrace" notification.
func SetTraceRoute(h SetTraceHandler) harpy.RouterOption {
	return harpy.WithRoute(
		"$/setTrace",
		func(ctx context.Context, p SetTraceParams) (any, error) {
			return nil, h.HandleSetTrace(ctx, p)
		},
	)
}

// ---------------------------------------------------------------------------------------------------------------------
// STRUCTURES
// ---------------------------------------------------------------------------------------------------------------------

// A special text edit with an additional change annotation.
//
// @since 3.16.0.
type AnnotatedTextEdit struct {
	TextEdit
	// The actual identifier of the change annotation
	AnnotationId ChangeAnnotationIdentifier `json:"annotationId"`
}

func (x *AnnotatedTextEdit) UnmarshalJSON(data []byte) error {
	type plain AnnotatedTextEdit
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.AnnotationId == "" {
		return errors.New("\"annotationId\" property is required")
	}

	return nil
}

// The parameters passed via an apply workspace edit request.
type ApplyWorkspaceEditParams struct {
	// An optional label of the workspace edit. This label is
	// presented in the user interface for example on an undo
	// stack to undo the workspace edit.
	Label string `json:"label,omitempty"`
	// The edits to apply.
	Edit WorkspaceEdit `json:"edit"`
}

func (x *ApplyWorkspaceEditParams) UnmarshalJSON(data []byte) error {
	type plain ApplyWorkspaceEditParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Edit

	return nil
}

// The result returned from the apply workspace edit request.
//
// @since 3.17 renamed from ApplyWorkspaceEditResponse
type ApplyWorkspaceEditResult struct {
	// Indicates whether the edit was applied or not.
	Applied bool `json:"applied"`
	// An optional textual description for why the edit was not applied.
	// This may be used by the server for diagnostic logging or to provide
	// a suitable error for a request that triggered the edit.
	FailureReason string `json:"failureReason,omitempty"`
	// Depending on the client's failure handling strategy `failedChange` might
	// contain the index of the change that failed. This property is only available
	// if the client signals a `failureHandlingStrategy` in its client capabilities.
	FailedChange uint32 `json:"failedChange,omitempty"`
}

func (x *ApplyWorkspaceEditResult) UnmarshalJSON(data []byte) error {
	type plain ApplyWorkspaceEditResult
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Applied == false {
		return errors.New("\"applied\" property is required")
	}

	return nil
}

// A base for all symbol information.
type BaseSymbolInformation struct {
	// The name of this symbol.
	Name string `json:"name"`
	// The kind of this symbol.
	Kind SymbolKind `json:"kind"`
	// Tags for this symbol.
	//
	// @since 3.16.0
	Tags []SymbolTag `json:"tags,omitempty"`
	// The name of the symbol containing this symbol. This information is for
	// user interface purposes (e.g. to render a qualifier in the user interface
	// if necessary). It can't be used to re-infer a hierarchy for the document
	// symbols.
	ContainerName string `json:"containerName,omitempty"`
}

func (x *BaseSymbolInformation) UnmarshalJSON(data []byte) error {
	type plain BaseSymbolInformation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Name == "" {
		return errors.New("\"name\" property is required")
	}

	if x.Kind == 0 {
		return errors.New("\"kind\" property is required")
	}

	return nil
}

// @since 3.16.0
type CallHierarchyClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *CallHierarchyClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain CallHierarchyClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Represents an incoming call, e.g. a caller of a method or constructor.
//
// @since 3.16.0
type CallHierarchyIncomingCall struct {
	// The item that makes the call.
	From CallHierarchyItem `json:"from"`
	// The ranges at which the calls appear. This is relative to the caller
	// denoted by {@link CallHierarchyIncomingCall.from `this.from`}.
	FromRanges []Range `json:"fromRanges"`
}

func (x *CallHierarchyIncomingCall) UnmarshalJSON(data []byte) error {
	type plain CallHierarchyIncomingCall
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.From

	if x.FromRanges == nil {
		return errors.New("\"fromRanges\" property is required")
	}

	return nil
}

// The parameter of a `callHierarchy/incomingCalls` request.
//
// @since 3.16.0
type CallHierarchyIncomingCallsParams struct {
	WorkDoneProgressParams
	PartialResultParams
	Item CallHierarchyItem `json:"item"`
}

func (x *CallHierarchyIncomingCallsParams) UnmarshalJSON(data []byte) error {
	type plain CallHierarchyIncomingCallsParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Item

	return nil
}

// Represents programming constructs like functions or constructors in the context
// of call hierarchy.
//
// @since 3.16.0
type CallHierarchyItem struct {
	// The name of this item.
	Name string `json:"name"`
	// The kind of this item.
	Kind SymbolKind `json:"kind"`
	// Tags for this item.
	Tags []SymbolTag `json:"tags,omitempty"`
	// More detail for this item, e.g. the signature of a function.
	Detail string `json:"detail,omitempty"`
	// The resource identifier of this item.
	URI DocumentURI `json:"uri"`
	// The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
	Range Range `json:"range"`
	// The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
	// Must be contained by the {@link CallHierarchyItem.range `range`}.
	SelectionRange Range `json:"selectionRange"`
	// A data entry field that is preserved between a call hierarchy prepare and
	// incoming calls or outgoing calls requests.
	Data any `json:"data,omitempty"`
}

func (x *CallHierarchyItem) UnmarshalJSON(data []byte) error {
	type plain CallHierarchyItem
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Name == "" {
		return errors.New("\"name\" property is required")
	}

	if x.Kind == 0 {
		return errors.New("\"kind\" property is required")
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	var _ json.Unmarshaler = &x.Range

	var _ json.Unmarshaler = &x.SelectionRange

	return nil
}

// Call hierarchy options used during static registration.
//
// @since 3.16.0
type CallHierarchyOptions struct {
	WorkDoneProgressOptions
}

func (x *CallHierarchyOptions) UnmarshalJSON(data []byte) error {
	type plain CallHierarchyOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
//
// @since 3.16.0
type CallHierarchyOutgoingCall struct {
	// The item that is called.
	To CallHierarchyItem `json:"to"`
	// The range at which this item is called. This is the range relative to the caller, e.g the item
	// passed to {@link CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls `provideCallHierarchyOutgoingCalls`}
	// and not {@link CallHierarchyOutgoingCall.to `this.to`}.
	FromRanges []Range `json:"fromRanges"`
}

func (x *CallHierarchyOutgoingCall) UnmarshalJSON(data []byte) error {
	type plain CallHierarchyOutgoingCall
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.To

	if x.FromRanges == nil {
		return errors.New("\"fromRanges\" property is required")
	}

	return nil
}

// The parameter of a `callHierarchy/outgoingCalls` request.
//
// @since 3.16.0
type CallHierarchyOutgoingCallsParams struct {
	WorkDoneProgressParams
	PartialResultParams
	Item CallHierarchyItem `json:"item"`
}

func (x *CallHierarchyOutgoingCallsParams) UnmarshalJSON(data []byte) error {
	type plain CallHierarchyOutgoingCallsParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Item

	return nil
}

// The parameter of a `textDocument/prepareCallHierarchy` request.
//
// @since 3.16.0
type CallHierarchyPrepareParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
}

func (x *CallHierarchyPrepareParams) UnmarshalJSON(data []byte) error {
	type plain CallHierarchyPrepareParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Call hierarchy options used during static or dynamic registration.
//
// @since 3.16.0
type CallHierarchyRegistrationOptions struct {
	TextDocumentRegistrationOptions
	CallHierarchyOptions
	StaticRegistrationOptions
}

func (x *CallHierarchyRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain CallHierarchyRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type CancelParams struct {
	// The request id to cancel.
	Id OneOf2[int32, string] `json:"id"`
}

func (x *CancelParams) UnmarshalJSON(data []byte) error {
	type plain CancelParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Id

	return nil
}

// Additional information that describes document changes.
//
// @since 3.16.0
type ChangeAnnotation struct {
	// A human-readable string describing the actual change. The string
	// is rendered prominent in the user interface.
	Label string `json:"label"`
	// A flag which indicates that user confirmation is needed
	// before applying the change.
	NeedsConfirmation bool `json:"needsConfirmation,omitempty"`
	// A human-readable string which is rendered less prominent in
	// the user interface.
	Description string `json:"description,omitempty"`
}

func (x *ChangeAnnotation) UnmarshalJSON(data []byte) error {
	type plain ChangeAnnotation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Label == "" {
		return errors.New("\"label\" property is required")
	}

	return nil
}

// Defines the capabilities provided by the client.
type ClientCapabilities struct {
	// Workspace specific client capabilities.
	Workspace *WorkspaceClientCapabilities `json:"workspace,omitempty"`
	// Text document specific client capabilities.
	TextDocument *TextDocumentClientCapabilities `json:"textDocument,omitempty"`
	// Capabilities specific to the notebook document support.
	//
	// @since 3.17.0
	NotebookDocument *NotebookDocumentClientCapabilities `json:"notebookDocument,omitempty"`
	// Window specific client capabilities.
	Window *WindowClientCapabilities `json:"window,omitempty"`
	// General client capabilities.
	//
	// @since 3.16.0
	General *GeneralClientCapabilities `json:"general,omitempty"`
	// Experimental client capabilities.
	Experimental any `json:"experimental,omitempty"`
}

func (x *ClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain ClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A code action represents a change that can be performed in code, e.g. to fix a problem or
// to refactor code.
//
// A CodeAction must set either `edit` and/or a `command`. If both are supplied, the `edit` is applied first, then the `command` is executed.
type CodeAction struct {
	// A short, human-readable, title for this code action.
	Title string `json:"title"`
	// The kind of the code action.
	//
	// Used to filter code actions.
	Kind CodeActionKind `json:"kind,omitempty"`
	// The diagnostics that this code action resolves.
	Diagnostics []Diagnostic `json:"diagnostics,omitempty"`
	// Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
	// by keybindings.
	//
	// A quick fix should be marked preferred if it properly addresses the underlying error.
	// A refactoring should be marked preferred if it is the most reasonable choice of actions to take.
	//
	// @since 3.15.0
	IsPreferred bool `json:"isPreferred,omitempty"`
	// Marks that the code action cannot currently be applied.
	//
	// Clients should follow the following guidelines regarding disabled code actions:
	//
	//   - Disabled code actions are not shown in automatic [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
	//     code action menus.
	//
	//   - Disabled actions are shown as faded out in the code action menu when the user requests a more specific type
	//     of code action, such as refactorings.
	//
	//   - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
	//     that auto applies a code action and only disabled code actions are returned, the client should show the user an
	//     error message with `reason` in the editor.
	//
	// @since 3.16.0
	Disabled *CodeActionDisabled `json:"disabled,omitempty"`
	// The workspace edit this code action performs.
	Edit *WorkspaceEdit `json:"edit,omitempty"`
	// A command this code action executes. If a code action
	// provides an edit and a command, first the edit is
	// executed and then the command.
	Command *Command `json:"command,omitempty"`
	// A data entry field that is preserved on a code action between
	// a `textDocument/codeAction` and a `codeAction/resolve` request.
	//
	// @since 3.16.0
	Data any `json:"data,omitempty"`
}

func (x *CodeAction) UnmarshalJSON(data []byte) error {
	type plain CodeAction
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Title == "" {
		return errors.New("\"title\" property is required")
	}

	return nil
}

type CodeActionDisabled struct {
	// Human readable description of why the code action is currently disabled.
	//
	// This is displayed in the code actions UI.
	Reason string `json:"reason"`
}

func (x *CodeActionDisabled) UnmarshalJSON(data []byte) error {
	type plain CodeActionDisabled
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Reason == "" {
		return errors.New("\"reason\" property is required")
	}

	return nil
}

// The Client Capabilities of a {@link CodeActionRequest}.
type CodeActionClientCapabilities struct {
	// Whether code action supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client support code action literals of type `CodeAction` as a valid
	// response of the `textDocument/codeAction` request. If the property is not
	// set the request can only return `Command` literals.
	//
	// @since 3.8.0
	CodeActionLiteralSupport *CodeActionClientCapabilitiesCodeActionLiteralSupport `json:"codeActionLiteralSupport,omitempty"`
	// Whether code action supports the `isPreferred` property.
	//
	// @since 3.15.0
	IsPreferredSupport bool `json:"isPreferredSupport,omitempty"`
	// Whether code action supports the `disabled` property.
	//
	// @since 3.16.0
	DisabledSupport bool `json:"disabledSupport,omitempty"`
	// Whether code action supports the `data` property which is
	// preserved between a `textDocument/codeAction` and a
	// `codeAction/resolve` request.
	//
	// @since 3.16.0
	DataSupport bool `json:"dataSupport,omitempty"`
	// Whether the client supports resolving additional code action
	// properties via a separate `codeAction/resolve` request.
	//
	// @since 3.16.0
	ResolveSupport *CodeActionClientCapabilitiesResolveSupport `json:"resolveSupport,omitempty"`
	// Whether the client honors the change annotations in
	// text edits and resource operations returned via the
	// `CodeAction#edit` property by for example presenting
	// the workspace edit in the user interface and asking
	// for confirmation.
	//
	// @since 3.16.0
	HonorsChangeAnnotations bool `json:"honorsChangeAnnotations,omitempty"`
}

func (x *CodeActionClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain CodeActionClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type CodeActionClientCapabilitiesCodeActionLiteralSupportCodeActionKind struct {
	// The code action kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	ValueSet []CodeActionKind `json:"valueSet"`
}

func (x *CodeActionClientCapabilitiesCodeActionLiteralSupportCodeActionKind) UnmarshalJSON(data []byte) error {
	type plain CodeActionClientCapabilitiesCodeActionLiteralSupportCodeActionKind
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.ValueSet == nil {
		return errors.New("\"valueSet\" property is required")
	}

	return nil
}

type CodeActionClientCapabilitiesCodeActionLiteralSupport struct {
	// The code action kind is support with the following value
	// set.
	CodeActionKind CodeActionClientCapabilitiesCodeActionLiteralSupportCodeActionKind `json:"codeActionKind"`
}

func (x *CodeActionClientCapabilitiesCodeActionLiteralSupport) UnmarshalJSON(data []byte) error {
	type plain CodeActionClientCapabilitiesCodeActionLiteralSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.CodeActionKind

	return nil
}

type CodeActionClientCapabilitiesResolveSupport struct {
	// The properties that a client can resolve lazily.
	Properties []string `json:"properties"`
}

func (x *CodeActionClientCapabilitiesResolveSupport) UnmarshalJSON(data []byte) error {
	type plain CodeActionClientCapabilitiesResolveSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Properties == nil {
		return errors.New("\"properties\" property is required")
	}

	return nil
}

// Contains additional diagnostic information about the context in which
// a {@link CodeActionProvider.provideCodeActions code action} is run.
type CodeActionContext struct {
	// An array of diagnostics known on the client side overlapping the range provided to the
	// `textDocument/codeAction` request. They are provided so that the server knows which
	// errors are currently presented to the user for the given range. There is no guarantee
	// that these accurately reflect the error state of the resource. The primary parameter
	// to compute code actions is the provided range.
	Diagnostics []Diagnostic `json:"diagnostics"`
	// Requested kind of actions to return.
	//
	// Actions not of this kind are filtered out by the client before being shown. So servers
	// can omit computing them.
	Only []CodeActionKind `json:"only,omitempty"`
	// The reason why code actions were requested.
	//
	// @since 3.17.0
	TriggerKind CodeActionTriggerKind `json:"triggerKind,omitempty"`
}

func (x *CodeActionContext) UnmarshalJSON(data []byte) error {
	type plain CodeActionContext
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Diagnostics == nil {
		return errors.New("\"diagnostics\" property is required")
	}

	return nil
}

// Provider options for a {@link CodeActionRequest}.
type CodeActionOptions struct {
	WorkDoneProgressOptions
	// CodeActionKinds that this server may return.
	//
	// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
	// may list out every specific kind they provide.
	CodeActionKinds []CodeActionKind `json:"codeActionKinds,omitempty"`
	// The server provides support to resolve additional
	// information for a code action.
	//
	// @since 3.16.0
	ResolveProvider bool `json:"resolveProvider,omitempty"`
}

func (x *CodeActionOptions) UnmarshalJSON(data []byte) error {
	type plain CodeActionOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters of a {@link CodeActionRequest}.
type CodeActionParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The document in which the command was invoked.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The range for which the command was invoked.
	Range Range `json:"range"`
	// Context carrying additional information.
	Context CodeActionContext `json:"context"`
}

func (x *CodeActionParams) UnmarshalJSON(data []byte) error {
	type plain CodeActionParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	var _ json.Unmarshaler = &x.Range

	var _ json.Unmarshaler = &x.Context

	return nil
}

// Registration options for a {@link CodeActionRequest}.
type CodeActionRegistrationOptions struct {
	TextDocumentRegistrationOptions
	CodeActionOptions
}

func (x *CodeActionRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain CodeActionRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Structure to capture a description for an error code.
//
// @since 3.16.0
type CodeDescription struct {
	// An URI to open with more information about the diagnostic error.
	Href URI `json:"href"`
}

func (x *CodeDescription) UnmarshalJSON(data []byte) error {
	type plain CodeDescription
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Href == (URI{}) {
		return errors.New("\"href\" property is required")
	}

	return nil
}

// A code lens represents a {@link Command command} that should be shown along with
// source text, like the number of references, a way to run tests, etc.
//
// A code lens is _unresolved_ when no command is associated to it. For performance
// reasons the creation of a code lens and resolving should be done in two stages.
type CodeLens struct {
	// The range in which this code lens is valid. Should only span a single line.
	Range Range `json:"range"`
	// The command this code lens represents.
	Command *Command `json:"command,omitempty"`
	// A data entry field that is preserved on a code lens item between
	// a {@link CodeLensRequest} and a [CodeLensResolveRequest]
	// (#CodeLensResolveRequest)
	Data any `json:"data,omitempty"`
}

func (x *CodeLens) UnmarshalJSON(data []byte) error {
	type plain CodeLens
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	return nil
}

// The client capabilities  of a {@link CodeLensRequest}.
type CodeLensClientCapabilities struct {
	// Whether code lens supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *CodeLensClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain CodeLensClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Code Lens provider options of a {@link CodeLensRequest}.
type CodeLensOptions struct {
	WorkDoneProgressOptions
	// Code lens has a resolve provider as well.
	ResolveProvider bool `json:"resolveProvider,omitempty"`
}

func (x *CodeLensOptions) UnmarshalJSON(data []byte) error {
	type plain CodeLensOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters of a {@link CodeLensRequest}.
type CodeLensParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The document to request code lens for.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (x *CodeLensParams) UnmarshalJSON(data []byte) error {
	type plain CodeLensParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	return nil
}

// Registration options for a {@link CodeLensRequest}.
type CodeLensRegistrationOptions struct {
	TextDocumentRegistrationOptions
	CodeLensOptions
}

func (x *CodeLensRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain CodeLensRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// @since 3.16.0
type CodeLensWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from the
	// server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// code lenses currently shown. It should be used with absolute care and is
	// useful for situation where a server for example detect a project wide
	// change that requires such a calculation.
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

func (x *CodeLensWorkspaceClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain CodeLensWorkspaceClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Represents a color in RGBA space.
type Color struct {
	// The red component of this color in the range [0-1].
	Red float64 `json:"red"`
	// The green component of this color in the range [0-1].
	Green float64 `json:"green"`
	// The blue component of this color in the range [0-1].
	Blue float64 `json:"blue"`
	// The alpha component of this color in the range [0-1].
	Alpha float64 `json:"alpha"`
}

func (x *Color) UnmarshalJSON(data []byte) error {
	type plain Color
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Red == 0 {
		return errors.New("\"red\" property is required")
	}

	if x.Green == 0 {
		return errors.New("\"green\" property is required")
	}

	if x.Blue == 0 {
		return errors.New("\"blue\" property is required")
	}

	if x.Alpha == 0 {
		return errors.New("\"alpha\" property is required")
	}

	return nil
}

// Represents a color range from a document.
type ColorInformation struct {
	// The range in the document where this color appears.
	Range Range `json:"range"`
	// The actual color value for this color range.
	Color Color `json:"color"`
}

func (x *ColorInformation) UnmarshalJSON(data []byte) error {
	type plain ColorInformation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	var _ json.Unmarshaler = &x.Color

	return nil
}

type ColorPresentation struct {
	// The label of this color presentation. It will be shown on the color
	// picker header. By default this is also the text that is inserted when selecting
	// this color presentation.
	Label string `json:"label"`
	// An {@link TextEdit edit} which is applied to a document when selecting
	// this presentation for the color.  When `falsy` the {@link ColorPresentation.label label}
	// is used.
	TextEdit *TextEdit `json:"textEdit,omitempty"`
	// An optional array of additional {@link TextEdit text edits} that are applied when
	// selecting this color presentation. Edits must not overlap with the main {@link ColorPresentation.textEdit edit} nor with themselves.
	AdditionalTextEdits []TextEdit `json:"additionalTextEdits,omitempty"`
}

func (x *ColorPresentation) UnmarshalJSON(data []byte) error {
	type plain ColorPresentation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Label == "" {
		return errors.New("\"label\" property is required")
	}

	return nil
}

// Parameters for a {@link ColorPresentationRequest}.
type ColorPresentationParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The color to request presentations for.
	Color Color `json:"color"`
	// The range where the color would be inserted. Serves as a context.
	Range Range `json:"range"`
}

func (x *ColorPresentationParams) UnmarshalJSON(data []byte) error {
	type plain ColorPresentationParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	var _ json.Unmarshaler = &x.Color

	var _ json.Unmarshaler = &x.Range

	return nil
}

// Represents a reference to a command. Provides a title which
// will be used to represent a command in the UI and, optionally,
// an array of arguments which will be passed to the command handler
// function when invoked.
type Command struct {
	// Title of the command, like `save`.
	Title string `json:"title"`
	// The identifier of the actual command handler.
	Command string `json:"command"`
	// Arguments that the command handler should be
	// invoked with.
	Arguments []any `json:"arguments,omitempty"`
}

func (x *Command) UnmarshalJSON(data []byte) error {
	type plain Command
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Title == "" {
		return errors.New("\"title\" property is required")
	}

	if x.Command == "" {
		return errors.New("\"command\" property is required")
	}

	return nil
}

// Completion client capabilities
type CompletionClientCapabilities struct {
	// Whether completion supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports the following `CompletionItem` specific
	// capabilities.
	CompletionItem     *CompletionClientCapabilitiesCompletionItem     `json:"completionItem,omitempty"`
	CompletionItemKind *CompletionClientCapabilitiesCompletionItemKind `json:"completionItemKind,omitempty"`
	// Defines how the client handles whitespace and indentation
	// when accepting a completion item that uses multi line
	// text in either `insertText` or `textEdit`.
	//
	// @since 3.17.0
	InsertTextMode InsertTextMode `json:"insertTextMode,omitempty"`
	// The client supports to send additional context information for a
	// `textDocument/completion` request.
	ContextSupport bool `json:"contextSupport,omitempty"`
	// The client supports the following `CompletionList` specific
	// capabilities.
	//
	// @since 3.17.0
	CompletionList *CompletionClientCapabilitiesCompletionList `json:"completionList,omitempty"`
}

func (x *CompletionClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain CompletionClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type CompletionClientCapabilitiesCompletionItemTagSupport struct {
	// The tags supported by the client.
	ValueSet []CompletionItemTag `json:"valueSet"`
}

func (x *CompletionClientCapabilitiesCompletionItemTagSupport) UnmarshalJSON(data []byte) error {
	type plain CompletionClientCapabilitiesCompletionItemTagSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.ValueSet == nil {
		return errors.New("\"valueSet\" property is required")
	}

	return nil
}

type CompletionClientCapabilitiesCompletionItemResolveSupport struct {
	// The properties that a client can resolve lazily.
	Properties []string `json:"properties"`
}

func (x *CompletionClientCapabilitiesCompletionItemResolveSupport) UnmarshalJSON(data []byte) error {
	type plain CompletionClientCapabilitiesCompletionItemResolveSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Properties == nil {
		return errors.New("\"properties\" property is required")
	}

	return nil
}

type CompletionClientCapabilitiesCompletionItemInsertTextModeSupport struct {
	ValueSet []InsertTextMode `json:"valueSet"`
}

func (x *CompletionClientCapabilitiesCompletionItemInsertTextModeSupport) UnmarshalJSON(data []byte) error {
	type plain CompletionClientCapabilitiesCompletionItemInsertTextModeSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.ValueSet == nil {
		return errors.New("\"valueSet\" property is required")
	}

	return nil
}

type CompletionClientCapabilitiesCompletionItem struct {
	// Client supports snippets as insert text.
	//
	// A snippet can define tab stops and placeholders with `$1`, `$2`
	// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
	// the end of the snippet. Placeholders with equal identifiers are linked,
	// that is typing in one will update others too.
	SnippetSupport bool `json:"snippetSupport,omitempty"`
	// Client supports commit characters on a completion item.
	CommitCharactersSupport bool `json:"commitCharactersSupport,omitempty"`
	// Client supports the following content formats for the documentation
	// property. The order describes the preferred format of the client.
	DocumentationFormat []MarkupKind `json:"documentationFormat,omitempty"`
	// Client supports the deprecated property on a completion item.
	DeprecatedSupport bool `json:"deprecatedSupport,omitempty"`
	// Client supports the preselect property on a completion item.
	PreselectSupport bool `json:"preselectSupport,omitempty"`
	// Client supports the tag property on a completion item. Clients supporting
	// tags have to handle unknown tags gracefully. Clients especially need to
	// preserve unknown tags when sending a completion item back to the server in
	// a resolve call.
	//
	// @since 3.15.0
	TagSupport *CompletionClientCapabilitiesCompletionItemTagSupport `json:"tagSupport,omitempty"`
	// Client support insert replace edit to control different behavior if a
	// completion item is inserted in the text or should replace text.
	//
	// @since 3.16.0
	InsertReplaceSupport bool `json:"insertReplaceSupport,omitempty"`
	// Indicates which properties a client can resolve lazily on a completion
	// item. Before version 3.16.0 only the predefined properties `documentation`
	// and `details` could be resolved lazily.
	//
	// @since 3.16.0
	ResolveSupport *CompletionClientCapabilitiesCompletionItemResolveSupport `json:"resolveSupport,omitempty"`
	// The client supports the `insertTextMode` property on
	// a completion item to override the whitespace handling mode
	// as defined by the client (see `insertTextMode`).
	//
	// @since 3.16.0
	InsertTextModeSupport *CompletionClientCapabilitiesCompletionItemInsertTextModeSupport `json:"insertTextModeSupport,omitempty"`
	// The client has support for completion item label
	// details (see also `CompletionItemLabelDetails`).
	//
	// @since 3.17.0
	LabelDetailsSupport bool `json:"labelDetailsSupport,omitempty"`
}

func (x *CompletionClientCapabilitiesCompletionItem) UnmarshalJSON(data []byte) error {
	type plain CompletionClientCapabilitiesCompletionItem
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type CompletionClientCapabilitiesCompletionItemKind struct {
	// The completion item kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	//
	// If this property is not present the client only supports
	// the completion items kinds from `Text` to `Reference` as defined in
	// the initial version of the protocol.
	ValueSet []CompletionItemKind `json:"valueSet,omitempty"`
}

func (x *CompletionClientCapabilitiesCompletionItemKind) UnmarshalJSON(data []byte) error {
	type plain CompletionClientCapabilitiesCompletionItemKind
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type CompletionClientCapabilitiesCompletionList struct {
	// The client supports the following itemDefaults on
	// a completion list.
	//
	// The value lists the supported property names of the
	// `CompletionList.itemDefaults` object. If omitted
	// no properties are supported.
	//
	// @since 3.17.0
	ItemDefaults []string `json:"itemDefaults,omitempty"`
}

func (x *CompletionClientCapabilitiesCompletionList) UnmarshalJSON(data []byte) error {
	type plain CompletionClientCapabilitiesCompletionList
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Contains additional information about the context in which a completion request is triggered.
type CompletionContext struct {
	// How the completion was triggered.
	TriggerKind CompletionTriggerKind `json:"triggerKind"`
	// The trigger character (a single character) that has trigger code complete.
	// Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`
	TriggerCharacter string `json:"triggerCharacter,omitempty"`
}

func (x *CompletionContext) UnmarshalJSON(data []byte) error {
	type plain CompletionContext
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.TriggerKind == 0 {
		return errors.New("\"triggerKind\" property is required")
	}

	return nil
}

// A completion item represents a text snippet that is
// proposed to complete text that is being typed.
type CompletionItem struct {
	// The label of this completion item.
	//
	// The label property is also by default the text that
	// is inserted when selecting this completion.
	//
	// If label details are provided the label itself should
	// be an unqualified name of the completion item.
	Label string `json:"label"`
	// Additional details for the label
	//
	// @since 3.17.0
	LabelDetails *CompletionItemLabelDetails `json:"labelDetails,omitempty"`
	// The kind of this completion item. Based of the kind
	// an icon is chosen by the editor.
	Kind CompletionItemKind `json:"kind,omitempty"`
	// Tags for this completion item.
	//
	// @since 3.15.0
	Tags []CompletionItemTag `json:"tags,omitempty"`
	// A human-readable string with additional information
	// about this item, like type or symbol information.
	Detail string `json:"detail,omitempty"`
	// A human-readable string that represents a doc-comment.
	Documentation *OneOf2[string, MarkupContent] `json:"documentation,omitempty"`
	// Indicates if this item is deprecated.
	// @deprecated Use `tags` instead.
	Deprecated bool `json:"deprecated,omitempty"`
	// Select this item when showing.
	//
	// *Note* that only one completion item can be selected and that the
	// tool / client decides which item that is. The rule is that the *first*
	// item of those that match best is selected.
	Preselect bool `json:"preselect,omitempty"`
	// A string that should be used when comparing this item
	// with other items. When `falsy` the {@link CompletionItem.label label}
	// is used.
	SortText string `json:"sortText,omitempty"`
	// A string that should be used when filtering a set of
	// completion items. When `falsy` the {@link CompletionItem.label label}
	// is used.
	FilterText string `json:"filterText,omitempty"`
	// A string that should be inserted into a document when selecting
	// this completion. When `falsy` the {@link CompletionItem.label label}
	// is used.
	//
	// The `insertText` is subject to interpretation by the client side.
	// Some tools might not take the string literally. For example
	// VS Code when code complete is requested in this example
	// `con<cursor position>` and a completion item with an `insertText` of
	// `console` is provided it will only insert `sole`. Therefore it is
	// recommended to use `textEdit` instead since it avoids additional client
	// side interpretation.
	InsertText string `json:"insertText,omitempty"`
	// The format of the insert text. The format applies to both the
	// `insertText` property and the `newText` property of a provided
	// `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
	//
	// Please note that the insertTextFormat doesn't apply to
	// `additionalTextEdits`.
	InsertTextFormat InsertTextFormat `json:"insertTextFormat,omitempty"`
	// How whitespace and indentation is handled during completion
	// item insertion. If not provided the clients default value depends on
	// the `textDocument.completion.insertTextMode` client capability.
	//
	// @since 3.16.0
	InsertTextMode InsertTextMode `json:"insertTextMode,omitempty"`
	// An {@link TextEdit edit} which is applied to a document when selecting
	// this completion. When an edit is provided the value of
	// {@link CompletionItem.insertText insertText} is ignored.
	//
	// Most editors support two different operations when accepting a completion
	// item. One is to insert a completion text and the other is to replace an
	// existing text with a completion text. Since this can usually not be
	// predetermined by a server it can report both ranges. Clients need to
	// signal support for `InsertReplaceEdits` via the
	// `textDocument.completion.insertReplaceSupport` client capability
	// property.
	//
	// *Note 1:* The text edit's range as well as both ranges from an insert
	// replace edit must be a [single line] and they must contain the position
	// at which completion has been requested.
	// *Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range
	// must be a prefix of the edit's replace range, that means it must be
	// contained and starting at the same position.
	//
	// @since 3.16.0 additional type `InsertReplaceEdit`
	TextEdit *OneOf2[TextEdit, InsertReplaceEdit] `json:"textEdit,omitempty"`
	// The edit text used if the completion item is part of a CompletionList and
	// CompletionList defines an item default for the text edit range.
	//
	// Clients will only honor this property if they opt into completion list
	// item defaults using the capability `completionList.itemDefaults`.
	//
	// If not provided and a list's default range is provided the label
	// property is used as a text.
	//
	// @since 3.17.0
	TextEditText string `json:"textEditText,omitempty"`
	// An optional array of additional {@link TextEdit text edits} that are applied when
	// selecting this completion. Edits must not overlap (including the same insert position)
	// with the main {@link CompletionItem.textEdit edit} nor with themselves.
	//
	// Additional text edits should be used to change text unrelated to the current cursor position
	// (for example adding an import statement at the top of the file if the completion item will
	// insert an unqualified type).
	AdditionalTextEdits []TextEdit `json:"additionalTextEdits,omitempty"`
	// An optional set of characters that when pressed while this completion is active will accept it first and
	// then type that character. *Note* that all commit characters should have `length=1` and that superfluous
	// characters will be ignored.
	CommitCharacters []string `json:"commitCharacters,omitempty"`
	// An optional {@link Command command} that is executed *after* inserting this completion. *Note* that
	// additional modifications to the current document should be described with the
	// {@link CompletionItem.additionalTextEdits additionalTextEdits}-property.
	Command *Command `json:"command,omitempty"`
	// A data entry field that is preserved on a completion item between a
	// {@link CompletionRequest} and a {@link CompletionResolveRequest}.
	Data any `json:"data,omitempty"`
}

func (x *CompletionItem) UnmarshalJSON(data []byte) error {
	type plain CompletionItem
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Label == "" {
		return errors.New("\"label\" property is required")
	}

	return nil
}

// Additional details for a completion item label.
//
// @since 3.17.0
type CompletionItemLabelDetails struct {
	// An optional string which is rendered less prominently directly after {@link CompletionItem.label label},
	// without any spacing. Should be used for function signatures and type annotations.
	Detail string `json:"detail,omitempty"`
	// An optional string which is rendered less prominently after {@link CompletionItem.detail}. Should be used
	// for fully qualified names and file paths.
	Description string `json:"description,omitempty"`
}

func (x *CompletionItemLabelDetails) UnmarshalJSON(data []byte) error {
	type plain CompletionItemLabelDetails
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Represents a collection of {@link CompletionItem completion items} to be presented
// in the editor.
type CompletionList struct {
	// This list it not complete. Further typing results in recomputing this list.
	//
	// Recomputed lists have all their items replaced (not appended) in the
	// incomplete completion sessions.
	IsIncomplete bool `json:"isIncomplete"`
	// In many cases the items of an actual completion result share the same
	// value for properties like `commitCharacters` or the range of a text
	// edit. A completion list can therefore define item defaults which will
	// be used if a completion item itself doesn't specify the value.
	//
	// If a completion list specifies a default value and a completion item
	// also specifies a corresponding value the one from the item is used.
	//
	// Servers are only allowed to return default values if the client
	// signals support for this via the `completionList.itemDefaults`
	// capability.
	//
	// @since 3.17.0
	ItemDefaults *CompletionListItemDefaults `json:"itemDefaults,omitempty"`
	// The completion items.
	Items []CompletionItem `json:"items"`
}

func (x *CompletionList) UnmarshalJSON(data []byte) error {
	type plain CompletionList
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.IsIncomplete == false {
		return errors.New("\"isIncomplete\" property is required")
	}

	if x.Items == nil {
		return errors.New("\"items\" property is required")
	}

	return nil
}

type CompletionListItemDefaultsEditRange struct {
	Insert  Range `json:"insert"`
	Replace Range `json:"replace"`
}

func (x *CompletionListItemDefaultsEditRange) UnmarshalJSON(data []byte) error {
	type plain CompletionListItemDefaultsEditRange
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Insert

	var _ json.Unmarshaler = &x.Replace

	return nil
}

type CompletionListItemDefaults struct {
	// A default commit character set.
	//
	// @since 3.17.0
	CommitCharacters []string `json:"commitCharacters,omitempty"`
	// A default edit range.
	//
	// @since 3.17.0
	EditRange *OneOf2[Range, CompletionListItemDefaultsEditRange] `json:"editRange,omitempty"`
	// A default insert text format.
	//
	// @since 3.17.0
	InsertTextFormat InsertTextFormat `json:"insertTextFormat,omitempty"`
	// A default insert text mode.
	//
	// @since 3.17.0
	InsertTextMode InsertTextMode `json:"insertTextMode,omitempty"`
	// A default data value.
	//
	// @since 3.17.0
	Data any `json:"data,omitempty"`
}

func (x *CompletionListItemDefaults) UnmarshalJSON(data []byte) error {
	type plain CompletionListItemDefaults
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Completion options.
type CompletionOptions struct {
	WorkDoneProgressOptions
	// Most tools trigger completion request automatically without explicitly requesting
	// it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
	// starts to type an identifier. For example if the user types `c` in a JavaScript file
	// code complete will automatically pop up present `console` besides others as a
	// completion item. Characters that make up identifiers don't need to be listed here.
	//
	// If code complete should automatically be trigger on characters not being valid inside
	// an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
	TriggerCharacters []string `json:"triggerCharacters,omitempty"`
	// The list of all possible characters that commit a completion. This field can be used
	// if clients don't support individual commit characters per completion item. See
	// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
	//
	// If a server provides both `allCommitCharacters` and commit characters on an individual
	// completion item the ones on the completion item win.
	//
	// @since 3.2.0
	AllCommitCharacters []string `json:"allCommitCharacters,omitempty"`
	// The server provides support to resolve additional
	// information for a completion item.
	ResolveProvider bool `json:"resolveProvider,omitempty"`
	// The server supports the following `CompletionItem` specific
	// capabilities.
	//
	// @since 3.17.0
	CompletionItem *CompletionOptionsCompletionItem `json:"completionItem,omitempty"`
}

func (x *CompletionOptions) UnmarshalJSON(data []byte) error {
	type plain CompletionOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type CompletionOptionsCompletionItem struct {
	// The server has support for completion item label
	// details (see also `CompletionItemLabelDetails`) when
	// receiving a completion item in a resolve call.
	//
	// @since 3.17.0
	LabelDetailsSupport bool `json:"labelDetailsSupport,omitempty"`
}

func (x *CompletionOptionsCompletionItem) UnmarshalJSON(data []byte) error {
	type plain CompletionOptionsCompletionItem
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Completion parameters
type CompletionParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
	PartialResultParams
	// The completion context. This is only available it the client specifies
	// to send this using the client capability `textDocument.completion.contextSupport === true`
	Context *CompletionContext `json:"context,omitempty"`
}

func (x *CompletionParams) UnmarshalJSON(data []byte) error {
	type plain CompletionParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Registration options for a {@link CompletionRequest}.
type CompletionRegistrationOptions struct {
	TextDocumentRegistrationOptions
	CompletionOptions
}

func (x *CompletionRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain CompletionRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type ConfigurationItem struct {
	// The scope to get the configuration section for.
	ScopeURI string `json:"scopeUri,omitempty"`
	// The configuration section asked for.
	Section string `json:"section,omitempty"`
}

func (x *ConfigurationItem) UnmarshalJSON(data []byte) error {
	type plain ConfigurationItem
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters of a configuration request.
type ConfigurationParams struct {
	Items []ConfigurationItem `json:"items"`
}

func (x *ConfigurationParams) UnmarshalJSON(data []byte) error {
	type plain ConfigurationParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Items == nil {
		return errors.New("\"items\" property is required")
	}

	return nil
}

// Create file operation.
type CreateFile struct {
	ResourceOperation
	// A create
	Kind createLiteral `json:"kind"`
	// The resource to create.
	URI DocumentURI `json:"uri"`
	// Additional options
	Options *CreateFileOptions `json:"options,omitempty"`
}

func (x *CreateFile) UnmarshalJSON(data []byte) error {
	type plain CreateFile
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Kind

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	return nil
}

// createLiteral is a type that must be represented as the JSON-string "create".
type createLiteral struct{}

func (createLiteral) MarshalJSON() ([]byte, error) {
	return marshal("create")
}
func (*createLiteral) UnmarshalJSON(data []byte) error {
	var value string
	if err := unmarshal(data, &value); err != nil {
		return err
	}

	if value != "create" {
		return errors.New("value must be \"create\"")
	}

	return nil
}

// Options to create a file.
type CreateFileOptions struct {
	// Overwrite existing file. Overwrite wins over `ignoreIfExists`
	Overwrite bool `json:"overwrite,omitempty"`
	// Ignore if exists.
	IgnoreIfExists bool `json:"ignoreIfExists,omitempty"`
}

func (x *CreateFileOptions) UnmarshalJSON(data []byte) error {
	type plain CreateFileOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters sent in notifications/requests for user-initiated creation of
// files.
//
// @since 3.16.0
type CreateFilesParams struct {
	// An array of all files/folders created in this operation.
	Files []FileCreate `json:"files"`
}

func (x *CreateFilesParams) UnmarshalJSON(data []byte) error {
	type plain CreateFilesParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Files == nil {
		return errors.New("\"files\" property is required")
	}

	return nil
}

// @since 3.14.0
type DeclarationClientCapabilities struct {
	// Whether declaration supports dynamic registration. If this is set to `true`
	// the client supports the new `DeclarationRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports additional metadata in the form of declaration links.
	LinkSupport bool `json:"linkSupport,omitempty"`
}

func (x *DeclarationClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DeclarationClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type DeclarationOptions struct {
	WorkDoneProgressOptions
}

func (x *DeclarationOptions) UnmarshalJSON(data []byte) error {
	type plain DeclarationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type DeclarationParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
	PartialResultParams
}

func (x *DeclarationParams) UnmarshalJSON(data []byte) error {
	type plain DeclarationParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type DeclarationRegistrationOptions struct {
	DeclarationOptions
	TextDocumentRegistrationOptions
	StaticRegistrationOptions
}

func (x *DeclarationRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DeclarationRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Client Capabilities for a {@link DefinitionRequest}.
type DefinitionClientCapabilities struct {
	// Whether definition supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports additional metadata in the form of definition links.
	//
	// @since 3.14.0
	LinkSupport bool `json:"linkSupport,omitempty"`
}

func (x *DefinitionClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DefinitionClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Server Capabilities for a {@link DefinitionRequest}.
type DefinitionOptions struct {
	WorkDoneProgressOptions
}

func (x *DefinitionOptions) UnmarshalJSON(data []byte) error {
	type plain DefinitionOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Parameters for a {@link DefinitionRequest}.
type DefinitionParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
	PartialResultParams
}

func (x *DefinitionParams) UnmarshalJSON(data []byte) error {
	type plain DefinitionParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Registration options for a {@link DefinitionRequest}.
type DefinitionRegistrationOptions struct {
	TextDocumentRegistrationOptions
	DefinitionOptions
}

func (x *DefinitionRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DefinitionRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Delete file operation
type DeleteFile struct {
	ResourceOperation
	// A delete
	Kind deleteLiteral `json:"kind"`
	// The file to delete.
	URI DocumentURI `json:"uri"`
	// Delete options.
	Options *DeleteFileOptions `json:"options,omitempty"`
}

func (x *DeleteFile) UnmarshalJSON(data []byte) error {
	type plain DeleteFile
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Kind

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	return nil
}

// deleteLiteral is a type that must be represented as the JSON-string "delete".
type deleteLiteral struct{}

func (deleteLiteral) MarshalJSON() ([]byte, error) {
	return marshal("delete")
}
func (*deleteLiteral) UnmarshalJSON(data []byte) error {
	var value string
	if err := unmarshal(data, &value); err != nil {
		return err
	}

	if value != "delete" {
		return errors.New("value must be \"delete\"")
	}

	return nil
}

// Delete file options
type DeleteFileOptions struct {
	// Delete the content recursively if a folder is denoted.
	Recursive bool `json:"recursive,omitempty"`
	// Ignore the operation if the file doesn't exist.
	IgnoreIfNotExists bool `json:"ignoreIfNotExists,omitempty"`
}

func (x *DeleteFileOptions) UnmarshalJSON(data []byte) error {
	type plain DeleteFileOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters sent in notifications/requests for user-initiated deletes of
// files.
//
// @since 3.16.0
type DeleteFilesParams struct {
	// An array of all files/folders deleted in this operation.
	Files []FileDelete `json:"files"`
}

func (x *DeleteFilesParams) UnmarshalJSON(data []byte) error {
	type plain DeleteFilesParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Files == nil {
		return errors.New("\"files\" property is required")
	}

	return nil
}

// Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
// are only valid in the scope of a resource.
type Diagnostic struct {
	// The range at which the message applies
	Range Range `json:"range"`
	// The diagnostic's severity. Can be omitted. If omitted it is up to the
	// client to interpret diagnostics as error, warning, info or hint.
	Severity DiagnosticSeverity `json:"severity,omitempty"`
	// The diagnostic's code, which usually appear in the user interface.
	Code *OneOf2[int32, string] `json:"code,omitempty"`
	// An optional property to describe the error code.
	// Requires the code field (above) to be present/not null.
	//
	// @since 3.16.0
	CodeDescription *CodeDescription `json:"codeDescription,omitempty"`
	// A human-readable string describing the source of this
	// diagnostic, e.g. 'typescript' or 'super lint'. It usually
	// appears in the user interface.
	Source string `json:"source,omitempty"`
	// The diagnostic's message. It usually appears in the user interface
	Message string `json:"message"`
	// Additional metadata about the diagnostic.
	//
	// @since 3.15.0
	Tags []DiagnosticTag `json:"tags,omitempty"`
	// An array of related diagnostic information, e.g. when symbol-names within
	// a scope collide all definitions can be marked via this property.
	RelatedInformation []DiagnosticRelatedInformation `json:"relatedInformation,omitempty"`
	// A data entry field that is preserved between a `textDocument/publishDiagnostics`
	// notification and `textDocument/codeAction` request.
	//
	// @since 3.16.0
	Data any `json:"data,omitempty"`
}

func (x *Diagnostic) UnmarshalJSON(data []byte) error {
	type plain Diagnostic
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	if x.Message == "" {
		return errors.New("\"message\" property is required")
	}

	return nil
}

// Client capabilities specific to diagnostic pull requests.
//
// @since 3.17.0
type DiagnosticClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Whether the clients supports related documents for document diagnostic pulls.
	RelatedDocumentSupport bool `json:"relatedDocumentSupport,omitempty"`
}

func (x *DiagnosticClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DiagnosticClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Diagnostic options.
//
// @since 3.17.0
type DiagnosticOptions struct {
	WorkDoneProgressOptions
	// An optional identifier under which the diagnostics are
	// managed by the client.
	Identifier string `json:"identifier,omitempty"`
	// Whether the language has inter file dependencies meaning that
	// editing code in one file can result in a different diagnostic
	// set in another file. Inter file dependencies are common for
	// most programming languages and typically uncommon for linters.
	InterFileDependencies bool `json:"interFileDependencies"`
	// The server provides support for workspace diagnostics as well.
	WorkspaceDiagnostics bool `json:"workspaceDiagnostics"`
}

func (x *DiagnosticOptions) UnmarshalJSON(data []byte) error {
	type plain DiagnosticOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.InterFileDependencies == false {
		return errors.New("\"interFileDependencies\" property is required")
	}

	if x.WorkspaceDiagnostics == false {
		return errors.New("\"workspaceDiagnostics\" property is required")
	}

	return nil
}

// Diagnostic registration options.
//
// @since 3.17.0
type DiagnosticRegistrationOptions struct {
	TextDocumentRegistrationOptions
	DiagnosticOptions
	StaticRegistrationOptions
}

func (x *DiagnosticRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DiagnosticRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Represents a related message and source code location for a diagnostic. This should be
// used to point to code locations that cause or related to a diagnostics, e.g when duplicating
// a symbol in a scope.
type DiagnosticRelatedInformation struct {
	// The location of this related diagnostic information.
	Location Location `json:"location"`
	// The message of this related diagnostic information.
	Message string `json:"message"`
}

func (x *DiagnosticRelatedInformation) UnmarshalJSON(data []byte) error {
	type plain DiagnosticRelatedInformation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Location

	if x.Message == "" {
		return errors.New("\"message\" property is required")
	}

	return nil
}

// Cancellation data returned from a diagnostic request.
//
// @since 3.17.0
type DiagnosticServerCancellationData struct {
	RetriggerRequest bool `json:"retriggerRequest"`
}

func (x *DiagnosticServerCancellationData) UnmarshalJSON(data []byte) error {
	type plain DiagnosticServerCancellationData
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.RetriggerRequest == false {
		return errors.New("\"retriggerRequest\" property is required")
	}

	return nil
}

// Workspace client capabilities specific to diagnostic pull requests.
//
// @since 3.17.0
type DiagnosticWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from
	// the server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// pulled diagnostics currently shown. It should be used with absolute care and
	// is useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

func (x *DiagnosticWorkspaceClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DiagnosticWorkspaceClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type DidChangeConfigurationClientCapabilities struct {
	// Did change configuration notification supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *DidChangeConfigurationClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DidChangeConfigurationClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters of a change configuration notification.
type DidChangeConfigurationParams struct {
	// The actual changed settings
	Settings any `json:"settings"`
}

func (x *DidChangeConfigurationParams) UnmarshalJSON(data []byte) error {
	type plain DidChangeConfigurationParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Settings == nil {
		return errors.New("\"settings\" property is required")
	}

	return nil
}

type DidChangeConfigurationRegistrationOptions struct {
	Section *OneOf2[string, []string] `json:"section,omitempty"`
}

func (x *DidChangeConfigurationRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DidChangeConfigurationRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The params sent in a change notebook document notification.
//
// @since 3.17.0
type DidChangeNotebookDocumentParams struct {
	// The notebook document that did change. The version number points
	// to the version after all provided changes have been applied. If
	// only the text document content of a cell changes the notebook version
	// doesn't necessarily have to change.
	NotebookDocument VersionedNotebookDocumentIdentifier `json:"notebookDocument"`
	// The actual changes to the notebook document.
	//
	// The changes describe single state changes to the notebook document.
	// So if there are two changes c1 (at array index 0) and c2 (at array
	// index 1) for a notebook in state S then c1 moves the notebook from
	// S to S' and c2 from S' to S”. So c1 is computed on the state S and
	// c2 is computed on the state S'.
	//
	// To mirror the content of a notebook using change events use the following approach:
	//   - start with the same initial content
	//   - apply the 'notebookDocument/didChange' notifications in the order you receive them.
	//   - apply the `NotebookChangeEvent`s in a single notification in the order
	//     you receive them.
	Change NotebookDocumentChangeEvent `json:"change"`
}

func (x *DidChangeNotebookDocumentParams) UnmarshalJSON(data []byte) error {
	type plain DidChangeNotebookDocumentParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.NotebookDocument

	var _ json.Unmarshaler = &x.Change

	return nil
}

// The change text document notification's parameters.
type DidChangeTextDocumentParams struct {
	// The document that did change. The version number points
	// to the version after all provided content changes have
	// been applied.
	TextDocument VersionedTextDocumentIdentifier `json:"textDocument"`
	// The actual content changes. The content changes describe single state changes
	// to the document. So if there are two content changes c1 (at array index 0) and
	// c2 (at array index 1) for a document in state S then c1 moves the document from
	// S to S' and c2 from S' to S”. So c1 is computed on the state S and c2 is computed
	// on the state S'.
	//
	// To mirror the content of a document using change events use the following approach:
	//   - start with the same initial content
	//   - apply the 'textDocument/didChange' notifications in the order you receive them.
	//   - apply the `TextDocumentContentChangeEvent`s in a single notification in the order
	//     you receive them.
	ContentChanges []TextDocumentContentChangeEvent `json:"contentChanges"`
}

func (x *DidChangeTextDocumentParams) UnmarshalJSON(data []byte) error {
	type plain DidChangeTextDocumentParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	if x.ContentChanges == nil {
		return errors.New("\"contentChanges\" property is required")
	}

	return nil
}

type DidChangeWatchedFilesClientCapabilities struct {
	// Did change watched files notification supports dynamic registration. Please note
	// that the current protocol doesn't support static configuration for file changes
	// from the server side.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Whether the client has support for {@link  RelativePattern relative pattern}
	// or not.
	//
	// @since 3.17.0
	RelativePatternSupport bool `json:"relativePatternSupport,omitempty"`
}

func (x *DidChangeWatchedFilesClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DidChangeWatchedFilesClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The watched files change notification's parameters.
type DidChangeWatchedFilesParams struct {
	// The actual file events.
	Changes []FileEvent `json:"changes"`
}

func (x *DidChangeWatchedFilesParams) UnmarshalJSON(data []byte) error {
	type plain DidChangeWatchedFilesParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Changes == nil {
		return errors.New("\"changes\" property is required")
	}

	return nil
}

// Describe options to be used when registered for text document change events.
type DidChangeWatchedFilesRegistrationOptions struct {
	// The watchers to register.
	Watchers []FileSystemWatcher `json:"watchers"`
}

func (x *DidChangeWatchedFilesRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DidChangeWatchedFilesRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Watchers == nil {
		return errors.New("\"watchers\" property is required")
	}

	return nil
}

// The parameters of a `workspace/didChangeWorkspaceFolders` notification.
type DidChangeWorkspaceFoldersParams struct {
	// The actual workspace folder change event.
	Event WorkspaceFoldersChangeEvent `json:"event"`
}

func (x *DidChangeWorkspaceFoldersParams) UnmarshalJSON(data []byte) error {
	type plain DidChangeWorkspaceFoldersParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Event

	return nil
}

// The params sent in a close notebook document notification.
//
// @since 3.17.0
type DidCloseNotebookDocumentParams struct {
	// The notebook document that got closed.
	NotebookDocument NotebookDocumentIdentifier `json:"notebookDocument"`
	// The text documents that represent the content
	// of a notebook cell that got closed.
	CellTextDocuments []TextDocumentIdentifier `json:"cellTextDocuments"`
}

func (x *DidCloseNotebookDocumentParams) UnmarshalJSON(data []byte) error {
	type plain DidCloseNotebookDocumentParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.NotebookDocument

	if x.CellTextDocuments == nil {
		return errors.New("\"cellTextDocuments\" property is required")
	}

	return nil
}

// The parameters sent in a close text document notification
type DidCloseTextDocumentParams struct {
	// The document that was closed.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (x *DidCloseTextDocumentParams) UnmarshalJSON(data []byte) error {
	type plain DidCloseTextDocumentParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	return nil
}

// The params sent in an open notebook document notification.
//
// @since 3.17.0
type DidOpenNotebookDocumentParams struct {
	// The notebook document that got opened.
	NotebookDocument NotebookDocument `json:"notebookDocument"`
	// The text documents that represent the content
	// of a notebook cell.
	CellTextDocuments []TextDocumentItem `json:"cellTextDocuments"`
}

func (x *DidOpenNotebookDocumentParams) UnmarshalJSON(data []byte) error {
	type plain DidOpenNotebookDocumentParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.NotebookDocument

	if x.CellTextDocuments == nil {
		return errors.New("\"cellTextDocuments\" property is required")
	}

	return nil
}

// The parameters sent in an open text document notification
type DidOpenTextDocumentParams struct {
	// The document that was opened.
	TextDocument TextDocumentItem `json:"textDocument"`
}

func (x *DidOpenTextDocumentParams) UnmarshalJSON(data []byte) error {
	type plain DidOpenTextDocumentParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	return nil
}

// The params sent in a save notebook document notification.
//
// @since 3.17.0
type DidSaveNotebookDocumentParams struct {
	// The notebook document that got saved.
	NotebookDocument NotebookDocumentIdentifier `json:"notebookDocument"`
}

func (x *DidSaveNotebookDocumentParams) UnmarshalJSON(data []byte) error {
	type plain DidSaveNotebookDocumentParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.NotebookDocument

	return nil
}

// The parameters sent in a save text document notification
type DidSaveTextDocumentParams struct {
	// The document that was saved.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// Optional the content when saved. Depends on the includeText value
	// when the save notification was requested.
	Text string `json:"text,omitempty"`
}

func (x *DidSaveTextDocumentParams) UnmarshalJSON(data []byte) error {
	type plain DidSaveTextDocumentParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	return nil
}

type DocumentColorClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `DocumentColorRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *DocumentColorClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DocumentColorClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type DocumentColorOptions struct {
	WorkDoneProgressOptions
}

func (x *DocumentColorOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentColorOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Parameters for a {@link DocumentColorRequest}.
type DocumentColorParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (x *DocumentColorParams) UnmarshalJSON(data []byte) error {
	type plain DocumentColorParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	return nil
}

type DocumentColorRegistrationOptions struct {
	TextDocumentRegistrationOptions
	DocumentColorOptions
	StaticRegistrationOptions
}

func (x *DocumentColorRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentColorRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Parameters of the document diagnostic request.
//
// @since 3.17.0
type DocumentDiagnosticParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The additional identifier  provided during registration.
	Identifier string `json:"identifier,omitempty"`
	// The result id of a previous response if provided.
	PreviousResultId string `json:"previousResultId,omitempty"`
}

func (x *DocumentDiagnosticParams) UnmarshalJSON(data []byte) error {
	type plain DocumentDiagnosticParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	return nil
}

// A partial result for a document diagnostic report.
//
// @since 3.17.0
type DocumentDiagnosticReportPartialResult struct {
	RelatedDocuments map[DocumentURI]OneOf2[FullDocumentDiagnosticReport, UnchangedDocumentDiagnosticReport] `json:"relatedDocuments"`
}

func (x *DocumentDiagnosticReportPartialResult) UnmarshalJSON(data []byte) error {
	type plain DocumentDiagnosticReportPartialResult
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.RelatedDocuments == nil {
		return errors.New("\"relatedDocuments\" property is required")
	}

	return nil
}

// Client capabilities of a {@link DocumentFormattingRequest}.
type DocumentFormattingClientCapabilities struct {
	// Whether formatting supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *DocumentFormattingClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DocumentFormattingClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Provider options for a {@link DocumentFormattingRequest}.
type DocumentFormattingOptions struct {
	WorkDoneProgressOptions
}

func (x *DocumentFormattingOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentFormattingOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters of a {@link DocumentFormattingRequest}.
type DocumentFormattingParams struct {
	WorkDoneProgressParams
	// The document to format.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The format options.
	Options FormattingOptions `json:"options"`
}

func (x *DocumentFormattingParams) UnmarshalJSON(data []byte) error {
	type plain DocumentFormattingParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	var _ json.Unmarshaler = &x.Options

	return nil
}

// Registration options for a {@link DocumentFormattingRequest}.
type DocumentFormattingRegistrationOptions struct {
	TextDocumentRegistrationOptions
	DocumentFormattingOptions
}

func (x *DocumentFormattingRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentFormattingRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A document highlight is a range inside a text document which deserves
// special attention. Usually a document highlight is visualized by changing
// the background color of its range.
type DocumentHighlight struct {
	// The range this highlight applies to.
	Range Range `json:"range"`
	// The highlight kind, default is {@link DocumentHighlightKind.Text text}.
	Kind DocumentHighlightKind `json:"kind,omitempty"`
}

func (x *DocumentHighlight) UnmarshalJSON(data []byte) error {
	type plain DocumentHighlight
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	return nil
}

// Client Capabilities for a {@link DocumentHighlightRequest}.
type DocumentHighlightClientCapabilities struct {
	// Whether document highlight supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *DocumentHighlightClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DocumentHighlightClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Provider options for a {@link DocumentHighlightRequest}.
type DocumentHighlightOptions struct {
	WorkDoneProgressOptions
}

func (x *DocumentHighlightOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentHighlightOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Parameters for a {@link DocumentHighlightRequest}.
type DocumentHighlightParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
	PartialResultParams
}

func (x *DocumentHighlightParams) UnmarshalJSON(data []byte) error {
	type plain DocumentHighlightParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Registration options for a {@link DocumentHighlightRequest}.
type DocumentHighlightRegistrationOptions struct {
	TextDocumentRegistrationOptions
	DocumentHighlightOptions
}

func (x *DocumentHighlightRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentHighlightRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A document link is a range in a text document that links to an internal or external resource, like another
// text document or a web site.
type DocumentLink struct {
	// The range this link applies to.
	Range Range `json:"range"`
	// The uri this link points to. If missing a resolve request is sent later.
	Target URI `json:"target,omitempty"`
	// The tooltip text when you hover over this link.
	//
	// If a tooltip is provided, is will be displayed in a string that includes instructions on how to
	// trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
	// user settings, and localization.
	//
	// @since 3.15.0
	Tooltip string `json:"tooltip,omitempty"`
	// A data entry field that is preserved on a document link between a
	// DocumentLinkRequest and a DocumentLinkResolveRequest.
	Data any `json:"data,omitempty"`
}

func (x *DocumentLink) UnmarshalJSON(data []byte) error {
	type plain DocumentLink
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	return nil
}

// The client capabilities of a {@link DocumentLinkRequest}.
type DocumentLinkClientCapabilities struct {
	// Whether document link supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Whether the client supports the `tooltip` property on `DocumentLink`.
	//
	// @since 3.15.0
	TooltipSupport bool `json:"tooltipSupport,omitempty"`
}

func (x *DocumentLinkClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DocumentLinkClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Provider options for a {@link DocumentLinkRequest}.
type DocumentLinkOptions struct {
	WorkDoneProgressOptions
	// Document links have a resolve provider as well.
	ResolveProvider bool `json:"resolveProvider,omitempty"`
}

func (x *DocumentLinkOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentLinkOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters of a {@link DocumentLinkRequest}.
type DocumentLinkParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The document to provide document links for.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (x *DocumentLinkParams) UnmarshalJSON(data []byte) error {
	type plain DocumentLinkParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	return nil
}

// Registration options for a {@link DocumentLinkRequest}.
type DocumentLinkRegistrationOptions struct {
	TextDocumentRegistrationOptions
	DocumentLinkOptions
}

func (x *DocumentLinkRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentLinkRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Client capabilities of a {@link DocumentOnTypeFormattingRequest}.
type DocumentOnTypeFormattingClientCapabilities struct {
	// Whether on type formatting supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *DocumentOnTypeFormattingClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DocumentOnTypeFormattingClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Provider options for a {@link DocumentOnTypeFormattingRequest}.
type DocumentOnTypeFormattingOptions struct {
	// A character on which formatting should be triggered, like `{`.
	FirstTriggerCharacter string `json:"firstTriggerCharacter"`
	// More trigger characters.
	MoreTriggerCharacter []string `json:"moreTriggerCharacter,omitempty"`
}

func (x *DocumentOnTypeFormattingOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentOnTypeFormattingOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.FirstTriggerCharacter == "" {
		return errors.New("\"firstTriggerCharacter\" property is required")
	}

	return nil
}

// The parameters of a {@link DocumentOnTypeFormattingRequest}.
type DocumentOnTypeFormattingParams struct {
	// The document to format.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The position around which the on type formatting should happen.
	// This is not necessarily the exact position where the character denoted
	// by the property `ch` got typed.
	Position Position `json:"position"`
	// The character that has been typed that triggered the formatting
	// on type request. That is not necessarily the last character that
	// got inserted into the document since the client could auto insert
	// characters as well (e.g. like automatic brace completion).
	Ch string `json:"ch"`
	// The formatting options.
	Options FormattingOptions `json:"options"`
}

func (x *DocumentOnTypeFormattingParams) UnmarshalJSON(data []byte) error {
	type plain DocumentOnTypeFormattingParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	var _ json.Unmarshaler = &x.Position

	if x.Ch == "" {
		return errors.New("\"ch\" property is required")
	}

	var _ json.Unmarshaler = &x.Options

	return nil
}

// Registration options for a {@link DocumentOnTypeFormattingRequest}.
type DocumentOnTypeFormattingRegistrationOptions struct {
	TextDocumentRegistrationOptions
	DocumentOnTypeFormattingOptions
}

func (x *DocumentOnTypeFormattingRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentOnTypeFormattingRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Client capabilities of a {@link DocumentRangeFormattingRequest}.
type DocumentRangeFormattingClientCapabilities struct {
	// Whether range formatting supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *DocumentRangeFormattingClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DocumentRangeFormattingClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Provider options for a {@link DocumentRangeFormattingRequest}.
type DocumentRangeFormattingOptions struct {
	WorkDoneProgressOptions
}

func (x *DocumentRangeFormattingOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentRangeFormattingOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters of a {@link DocumentRangeFormattingRequest}.
type DocumentRangeFormattingParams struct {
	WorkDoneProgressParams
	// The document to format.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The range to format
	Range Range `json:"range"`
	// The format options
	Options FormattingOptions `json:"options"`
}

func (x *DocumentRangeFormattingParams) UnmarshalJSON(data []byte) error {
	type plain DocumentRangeFormattingParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	var _ json.Unmarshaler = &x.Range

	var _ json.Unmarshaler = &x.Options

	return nil
}

// Registration options for a {@link DocumentRangeFormattingRequest}.
type DocumentRangeFormattingRegistrationOptions struct {
	TextDocumentRegistrationOptions
	DocumentRangeFormattingOptions
}

func (x *DocumentRangeFormattingRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentRangeFormattingRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Represents programming constructs like variables, classes, interfaces etc.
// that appear in a document. Document symbols can be hierarchical and they
// have two ranges: one that encloses its definition and one that points to
// its most interesting range, e.g. the range of an identifier.
type DocumentSymbol struct {
	// The name of this symbol. Will be displayed in the user interface and therefore must not be
	// an empty string or a string only consisting of white spaces.
	Name string `json:"name"`
	// More detail for this symbol, e.g the signature of a function.
	Detail string `json:"detail,omitempty"`
	// The kind of this symbol.
	Kind SymbolKind `json:"kind"`
	// Tags for this document symbol.
	//
	// @since 3.16.0
	Tags []SymbolTag `json:"tags,omitempty"`
	// Indicates if this symbol is deprecated.
	//
	// @deprecated Use tags instead
	Deprecated bool `json:"deprecated,omitempty"`
	// The range enclosing this symbol not including leading/trailing whitespace but everything else
	// like comments. This information is typically used to determine if the clients cursor is
	// inside the symbol to reveal in the symbol in the UI.
	Range Range `json:"range"`
	// The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.
	// Must be contained by the `range`.
	SelectionRange Range `json:"selectionRange"`
	// Children of this symbol, e.g. properties of a class.
	Children []DocumentSymbol `json:"children,omitempty"`
}

func (x *DocumentSymbol) UnmarshalJSON(data []byte) error {
	type plain DocumentSymbol
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Name == "" {
		return errors.New("\"name\" property is required")
	}

	if x.Kind == 0 {
		return errors.New("\"kind\" property is required")
	}

	var _ json.Unmarshaler = &x.Range

	var _ json.Unmarshaler = &x.SelectionRange

	return nil
}

// Client Capabilities for a {@link DocumentSymbolRequest}.
type DocumentSymbolClientCapabilities struct {
	// Whether document symbol supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Specific capabilities for the `SymbolKind` in the
	// `textDocument/documentSymbol` request.
	SymbolKind *DocumentSymbolClientCapabilitiesSymbolKind `json:"symbolKind,omitempty"`
	// The client supports hierarchical document symbols.
	HierarchicalDocumentSymbolSupport bool `json:"hierarchicalDocumentSymbolSupport,omitempty"`
	// The client supports tags on `SymbolInformation`. Tags are supported on
	// `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// @since 3.16.0
	TagSupport *DocumentSymbolClientCapabilitiesTagSupport `json:"tagSupport,omitempty"`
	// The client supports an additional label presented in the UI when
	// registering a document symbol provider.
	//
	// @since 3.16.0
	LabelSupport bool `json:"labelSupport,omitempty"`
}

func (x *DocumentSymbolClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain DocumentSymbolClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type DocumentSymbolClientCapabilitiesSymbolKind struct {
	// The symbol kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	//
	// If this property is not present the client only supports
	// the symbol kinds from `File` to `Array` as defined in
	// the initial version of the protocol.
	ValueSet []SymbolKind `json:"valueSet,omitempty"`
}

func (x *DocumentSymbolClientCapabilitiesSymbolKind) UnmarshalJSON(data []byte) error {
	type plain DocumentSymbolClientCapabilitiesSymbolKind
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type DocumentSymbolClientCapabilitiesTagSupport struct {
	// The tags supported by the client.
	ValueSet []SymbolTag `json:"valueSet"`
}

func (x *DocumentSymbolClientCapabilitiesTagSupport) UnmarshalJSON(data []byte) error {
	type plain DocumentSymbolClientCapabilitiesTagSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.ValueSet == nil {
		return errors.New("\"valueSet\" property is required")
	}

	return nil
}

// Provider options for a {@link DocumentSymbolRequest}.
type DocumentSymbolOptions struct {
	WorkDoneProgressOptions
	// A human-readable string that is shown when multiple outlines trees
	// are shown for the same document.
	//
	// @since 3.16.0
	Label string `json:"label,omitempty"`
}

func (x *DocumentSymbolOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentSymbolOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Parameters for a {@link DocumentSymbolRequest}.
type DocumentSymbolParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (x *DocumentSymbolParams) UnmarshalJSON(data []byte) error {
	type plain DocumentSymbolParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	return nil
}

// Registration options for a {@link DocumentSymbolRequest}.
type DocumentSymbolRegistrationOptions struct {
	TextDocumentRegistrationOptions
	DocumentSymbolOptions
}

func (x *DocumentSymbolRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain DocumentSymbolRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The client capabilities of a {@link ExecuteCommandRequest}.
type ExecuteCommandClientCapabilities struct {
	// Execute command supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *ExecuteCommandClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain ExecuteCommandClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The server capabilities of a {@link ExecuteCommandRequest}.
type ExecuteCommandOptions struct {
	WorkDoneProgressOptions
	// The commands to be executed on the server
	Commands []string `json:"commands"`
}

func (x *ExecuteCommandOptions) UnmarshalJSON(data []byte) error {
	type plain ExecuteCommandOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Commands == nil {
		return errors.New("\"commands\" property is required")
	}

	return nil
}

// The parameters of a {@link ExecuteCommandRequest}.
type ExecuteCommandParams struct {
	WorkDoneProgressParams
	// The identifier of the actual command handler.
	Command string `json:"command"`
	// Arguments that the command should be invoked with.
	Arguments []any `json:"arguments,omitempty"`
}

func (x *ExecuteCommandParams) UnmarshalJSON(data []byte) error {
	type plain ExecuteCommandParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Command == "" {
		return errors.New("\"command\" property is required")
	}

	return nil
}

// Registration options for a {@link ExecuteCommandRequest}.
type ExecuteCommandRegistrationOptions struct {
	ExecuteCommandOptions
}

func (x *ExecuteCommandRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain ExecuteCommandRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type ExecutionSummary struct {
	// A strict monotonically increasing value
	// indicating the execution order of a cell
	// inside a notebook.
	ExecutionOrder uint32 `json:"executionOrder"`
	// Whether the execution was successful or
	// not if known by the client.
	Success bool `json:"success,omitempty"`
}

func (x *ExecutionSummary) UnmarshalJSON(data []byte) error {
	type plain ExecutionSummary
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.ExecutionOrder == 0 {
		return errors.New("\"executionOrder\" property is required")
	}

	return nil
}

// Represents information on a file/folder create.
//
// @since 3.16.0
type FileCreate struct {
	// A file:// URI for the location of the file/folder being created.
	URI string `json:"uri"`
}

func (x *FileCreate) UnmarshalJSON(data []byte) error {
	type plain FileCreate
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == "" {
		return errors.New("\"uri\" property is required")
	}

	return nil
}

// Represents information on a file/folder delete.
//
// @since 3.16.0
type FileDelete struct {
	// A file:// URI for the location of the file/folder being deleted.
	URI string `json:"uri"`
}

func (x *FileDelete) UnmarshalJSON(data []byte) error {
	type plain FileDelete
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == "" {
		return errors.New("\"uri\" property is required")
	}

	return nil
}

// An event describing a file change.
type FileEvent struct {
	// The file's uri.
	URI DocumentURI `json:"uri"`
	// The change type.
	Type FileChangeType `json:"type"`
}

func (x *FileEvent) UnmarshalJSON(data []byte) error {
	type plain FileEvent
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	if x.Type == 0 {
		return errors.New("\"type\" property is required")
	}

	return nil
}

// Capabilities relating to events from file operations by the user in the client.
//
// These events do not come from the file system, they come from user operations
// like renaming a file in the UI.
//
// @since 3.16.0
type FileOperationClientCapabilities struct {
	// Whether the client supports dynamic registration for file requests/notifications.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client has support for sending didCreateFiles notifications.
	DidCreate bool `json:"didCreate,omitempty"`
	// The client has support for sending willCreateFiles requests.
	WillCreate bool `json:"willCreate,omitempty"`
	// The client has support for sending didRenameFiles notifications.
	DidRename bool `json:"didRename,omitempty"`
	// The client has support for sending willRenameFiles requests.
	WillRename bool `json:"willRename,omitempty"`
	// The client has support for sending didDeleteFiles notifications.
	DidDelete bool `json:"didDelete,omitempty"`
	// The client has support for sending willDeleteFiles requests.
	WillDelete bool `json:"willDelete,omitempty"`
}

func (x *FileOperationClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain FileOperationClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A filter to describe in which file operation requests or notifications
// the server is interested in receiving.
//
// @since 3.16.0
type FileOperationFilter struct {
	// A Uri scheme like `file` or `untitled`.
	Scheme string `json:"scheme,omitempty"`
	// The actual file operation pattern.
	Pattern FileOperationPattern `json:"pattern"`
}

func (x *FileOperationFilter) UnmarshalJSON(data []byte) error {
	type plain FileOperationFilter
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Pattern

	return nil
}

// Options for notifications/requests for user operations on files.
//
// @since 3.16.0
type FileOperationOptions struct {
	// The server is interested in receiving didCreateFiles notifications.
	DidCreate *FileOperationRegistrationOptions `json:"didCreate,omitempty"`
	// The server is interested in receiving willCreateFiles requests.
	WillCreate *FileOperationRegistrationOptions `json:"willCreate,omitempty"`
	// The server is interested in receiving didRenameFiles notifications.
	DidRename *FileOperationRegistrationOptions `json:"didRename,omitempty"`
	// The server is interested in receiving willRenameFiles requests.
	WillRename *FileOperationRegistrationOptions `json:"willRename,omitempty"`
	// The server is interested in receiving didDeleteFiles file notifications.
	DidDelete *FileOperationRegistrationOptions `json:"didDelete,omitempty"`
	// The server is interested in receiving willDeleteFiles file requests.
	WillDelete *FileOperationRegistrationOptions `json:"willDelete,omitempty"`
}

func (x *FileOperationOptions) UnmarshalJSON(data []byte) error {
	type plain FileOperationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A pattern to describe in which file operation requests or notifications
// the server is interested in receiving.
//
// @since 3.16.0
type FileOperationPattern struct {
	// The glob pattern to match. Glob patterns can have the following syntax:
	// - `*` to match one or more characters in a path segment
	// - `?` to match on one character in a path segment
	// - `**` to match any number of path segments, including none
	// - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
	// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
	// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
	Glob string `json:"glob"`
	// Whether to match files or folders with this pattern.
	//
	// Matches both if undefined.
	Matches FileOperationPatternKind `json:"matches,omitempty"`
	// Additional options used during matching.
	Options *FileOperationPatternOptions `json:"options,omitempty"`
}

func (x *FileOperationPattern) UnmarshalJSON(data []byte) error {
	type plain FileOperationPattern
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Glob == "" {
		return errors.New("\"glob\" property is required")
	}

	return nil
}

// Matching options for the file operation pattern.
//
// @since 3.16.0
type FileOperationPatternOptions struct {
	// The pattern should be matched ignoring casing.
	IgnoreCase bool `json:"ignoreCase,omitempty"`
}

func (x *FileOperationPatternOptions) UnmarshalJSON(data []byte) error {
	type plain FileOperationPatternOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The options to register for file operations.
//
// @since 3.16.0
type FileOperationRegistrationOptions struct {
	// The actual filters.
	Filters []FileOperationFilter `json:"filters"`
}

func (x *FileOperationRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain FileOperationRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Filters == nil {
		return errors.New("\"filters\" property is required")
	}

	return nil
}

// Represents information on a file/folder rename.
//
// @since 3.16.0
type FileRename struct {
	// A file:// URI for the original location of the file/folder being renamed.
	OldURI string `json:"oldUri"`
	// A file:// URI for the new location of the file/folder being renamed.
	NewURI string `json:"newUri"`
}

func (x *FileRename) UnmarshalJSON(data []byte) error {
	type plain FileRename
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.OldURI == "" {
		return errors.New("\"oldUri\" property is required")
	}

	if x.NewURI == "" {
		return errors.New("\"newUri\" property is required")
	}

	return nil
}

type FileSystemWatcher struct {
	// The glob pattern to watch. See {@link GlobPattern glob pattern} for more detail.
	//
	// @since 3.17.0 support for relative patterns.
	GlobPattern GlobPattern `json:"globPattern"`
	// The kind of events of interest. If omitted it defaults
	// to WatchKind.Create | WatchKind.Change | WatchKind.Delete
	// which is 7.
	Kind WatchKind `json:"kind,omitempty"`
}

func (x *FileSystemWatcher) UnmarshalJSON(data []byte) error {
	type plain FileSystemWatcher
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.GlobPattern

	return nil
}

// Represents a folding range. To be valid, start and end line must be bigger than zero and smaller
// than the number of lines in the document. Clients are free to ignore invalid ranges.
type FoldingRange struct {
	// The zero-based start line of the range to fold. The folded area starts after the line's last character.
	// To be valid, the end must be zero or larger and smaller than the number of lines in the document.
	StartLine uint32 `json:"startLine"`
	// The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line.
	StartCharacter uint32 `json:"startCharacter,omitempty"`
	// The zero-based end line of the range to fold. The folded area ends with the line's last character.
	// To be valid, the end must be zero or larger and smaller than the number of lines in the document.
	EndLine uint32 `json:"endLine"`
	// The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line.
	EndCharacter uint32 `json:"endCharacter,omitempty"`
	// Describes the kind of the folding range such as `comment' or 'region'. The kind
	// is used to categorize folding ranges and used by commands like 'Fold all comments'.
	// See {@link FoldingRangeKind} for an enumeration of standardized kinds.
	Kind FoldingRangeKind `json:"kind,omitempty"`
	// The text that the client should show when the specified range is
	// collapsed. If not defined or not supported by the client, a default
	// will be chosen by the client.
	//
	// @since 3.17.0
	CollapsedText string `json:"collapsedText,omitempty"`
}

func (x *FoldingRange) UnmarshalJSON(data []byte) error {
	type plain FoldingRange
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.StartLine == 0 {
		return errors.New("\"startLine\" property is required")
	}

	if x.EndLine == 0 {
		return errors.New("\"endLine\" property is required")
	}

	return nil
}

type FoldingRangeClientCapabilities struct {
	// Whether implementation supports dynamic registration for folding range
	// providers. If this is set to `true` the client supports the new
	// `FoldingRangeRegistrationOptions` return value for the corresponding
	// server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The maximum number of folding ranges that the client prefers to receive
	// per document. The value serves as a hint, servers are free to follow the
	// limit.
	RangeLimit uint32 `json:"rangeLimit,omitempty"`
	// If set, the client signals that it only supports folding complete lines.
	// If set, client will ignore specified `startCharacter` and `endCharacter`
	// properties in a FoldingRange.
	LineFoldingOnly bool `json:"lineFoldingOnly,omitempty"`
	// Specific options for the folding range kind.
	//
	// @since 3.17.0
	FoldingRangeKind *FoldingRangeClientCapabilitiesFoldingRangeKind `json:"foldingRangeKind,omitempty"`
	// Specific options for the folding range.
	//
	// @since 3.17.0
	FoldingRange *FoldingRangeClientCapabilitiesFoldingRange `json:"foldingRange,omitempty"`
}

func (x *FoldingRangeClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain FoldingRangeClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type FoldingRangeClientCapabilitiesFoldingRangeKind struct {
	// The folding range kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	ValueSet []FoldingRangeKind `json:"valueSet,omitempty"`
}

func (x *FoldingRangeClientCapabilitiesFoldingRangeKind) UnmarshalJSON(data []byte) error {
	type plain FoldingRangeClientCapabilitiesFoldingRangeKind
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type FoldingRangeClientCapabilitiesFoldingRange struct {
	// If set, the client signals that it supports setting collapsedText on
	// folding ranges to display custom labels instead of the default text.
	//
	// @since 3.17.0
	CollapsedText bool `json:"collapsedText,omitempty"`
}

func (x *FoldingRangeClientCapabilitiesFoldingRange) UnmarshalJSON(data []byte) error {
	type plain FoldingRangeClientCapabilitiesFoldingRange
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type FoldingRangeOptions struct {
	WorkDoneProgressOptions
}

func (x *FoldingRangeOptions) UnmarshalJSON(data []byte) error {
	type plain FoldingRangeOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Parameters for a {@link FoldingRangeRequest}.
type FoldingRangeParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (x *FoldingRangeParams) UnmarshalJSON(data []byte) error {
	type plain FoldingRangeParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	return nil
}

type FoldingRangeRegistrationOptions struct {
	TextDocumentRegistrationOptions
	FoldingRangeOptions
	StaticRegistrationOptions
}

func (x *FoldingRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain FoldingRangeRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Value-object describing what options formatting should use.
type FormattingOptions struct {
	// Size of a tab in spaces.
	TabSize uint32 `json:"tabSize"`
	// Prefer spaces over tabs.
	InsertSpaces bool `json:"insertSpaces"`
	// Trim trailing whitespace on a line.
	//
	// @since 3.15.0
	TrimTrailingWhitespace bool `json:"trimTrailingWhitespace,omitempty"`
	// Insert a newline character at the end of the file if one does not exist.
	//
	// @since 3.15.0
	InsertFinalNewline bool `json:"insertFinalNewline,omitempty"`
	// Trim all newlines after the final newline at the end of the file.
	//
	// @since 3.15.0
	TrimFinalNewlines bool `json:"trimFinalNewlines,omitempty"`
}

func (x *FormattingOptions) UnmarshalJSON(data []byte) error {
	type plain FormattingOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.TabSize == 0 {
		return errors.New("\"tabSize\" property is required")
	}

	if x.InsertSpaces == false {
		return errors.New("\"insertSpaces\" property is required")
	}

	return nil
}

// A diagnostic report with a full set of problems.
//
// @since 3.17.0
type FullDocumentDiagnosticReport struct {
	// A full document diagnostic report.
	Kind fullLiteral `json:"kind"`
	// An optional result id. If provided it will
	// be sent on the next diagnostic request for the
	// same document.
	ResultId string `json:"resultId,omitempty"`
	// The actual items.
	Items []Diagnostic `json:"items"`
}

func (x *FullDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	type plain FullDocumentDiagnosticReport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Kind

	if x.Items == nil {
		return errors.New("\"items\" property is required")
	}

	return nil
}

// fullLiteral is a type that must be represented as the JSON-string "full".
type fullLiteral struct{}

func (fullLiteral) MarshalJSON() ([]byte, error) {
	return marshal("full")
}
func (*fullLiteral) UnmarshalJSON(data []byte) error {
	var value string
	if err := unmarshal(data, &value); err != nil {
		return err
	}

	if value != "full" {
		return errors.New("value must be \"full\"")
	}

	return nil
}

// General client capabilities.
//
// @since 3.16.0
type GeneralClientCapabilities struct {
	// Client capability that signals how the client
	// handles stale requests (e.g. a request
	// for which the client will not process the response
	// anymore since the information is outdated).
	//
	// @since 3.17.0
	StaleRequestSupport *GeneralClientCapabilitiesStaleRequestSupport `json:"staleRequestSupport,omitempty"`
	// Client capabilities specific to regular expressions.
	//
	// @since 3.16.0
	RegularExpressions *RegularExpressionsClientCapabilities `json:"regularExpressions,omitempty"`
	// Client capabilities specific to the client's markdown parser.
	//
	// @since 3.16.0
	Markdown *MarkdownClientCapabilities `json:"markdown,omitempty"`
	// The position encodings supported by the client. Client and server
	// have to agree on the same position encoding to ensure that offsets
	// (e.g. character position in a line) are interpreted the same on both
	// sides.
	//
	// To keep the protocol backwards compatible the following applies: if
	// the value 'utf-16' is missing from the array of position encodings
	// servers can assume that the client supports UTF-16. UTF-16 is
	// therefore a mandatory encoding.
	//
	// If omitted it defaults to ['utf-16'].
	//
	// Implementation considerations: since the conversion from one encoding
	// into another requires the content of the file / line the conversion
	// is best done where the file is read which is usually on the server
	// side.
	//
	// @since 3.17.0
	PositionEncodings []PositionEncodingKind `json:"positionEncodings,omitempty"`
}

func (x *GeneralClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain GeneralClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type GeneralClientCapabilitiesStaleRequestSupport struct {
	// The client will actively cancel the request.
	Cancel bool `json:"cancel"`
	// The list of requests for which the client
	// will retry the request if it receives a
	// response with error code `ContentModified`
	RetryOnContentModified []string `json:"retryOnContentModified"`
}

func (x *GeneralClientCapabilitiesStaleRequestSupport) UnmarshalJSON(data []byte) error {
	type plain GeneralClientCapabilitiesStaleRequestSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Cancel == false {
		return errors.New("\"cancel\" property is required")
	}

	if x.RetryOnContentModified == nil {
		return errors.New("\"retryOnContentModified\" property is required")
	}

	return nil
}

// The result of a hover request.
type Hover struct {
	// The hover's content
	Contents OneOf3[MarkupContent, MarkedString, []MarkedString] `json:"contents"`
	// An optional range inside the text document that is used to
	// visualize the hover, e.g. by changing the background color.
	Range *Range `json:"range,omitempty"`
}

func (x *Hover) UnmarshalJSON(data []byte) error {
	type plain Hover
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Contents

	return nil
}

type HoverClientCapabilities struct {
	// Whether hover supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Client supports the following content formats for the content
	// property. The order describes the preferred format of the client.
	ContentFormat []MarkupKind `json:"contentFormat,omitempty"`
}

func (x *HoverClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain HoverClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Hover options.
type HoverOptions struct {
	WorkDoneProgressOptions
}

func (x *HoverOptions) UnmarshalJSON(data []byte) error {
	type plain HoverOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Parameters for a {@link HoverRequest}.
type HoverParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
}

func (x *HoverParams) UnmarshalJSON(data []byte) error {
	type plain HoverParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Registration options for a {@link HoverRequest}.
type HoverRegistrationOptions struct {
	TextDocumentRegistrationOptions
	HoverOptions
}

func (x *HoverRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain HoverRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// @since 3.6.0
type ImplementationClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `ImplementationRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports additional metadata in the form of definition links.
	//
	// @since 3.14.0
	LinkSupport bool `json:"linkSupport,omitempty"`
}

func (x *ImplementationClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain ImplementationClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type ImplementationOptions struct {
	WorkDoneProgressOptions
}

func (x *ImplementationOptions) UnmarshalJSON(data []byte) error {
	type plain ImplementationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type ImplementationParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
	PartialResultParams
}

func (x *ImplementationParams) UnmarshalJSON(data []byte) error {
	type plain ImplementationParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type ImplementationRegistrationOptions struct {
	TextDocumentRegistrationOptions
	ImplementationOptions
	StaticRegistrationOptions
}

func (x *ImplementationRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain ImplementationRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The data type of the ResponseError if the
// initialize request fails.
type InitializeError struct {
	// Indicates whether the client execute the following retry logic:
	// (1) show the message provided by the ResponseError to the user
	// (2) user selects retry or cancel
	// (3) if user selected retry the initialize method is sent again.
	Retry bool `json:"retry"`
}

func (x *InitializeError) UnmarshalJSON(data []byte) error {
	type plain InitializeError
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Retry == false {
		return errors.New("\"retry\" property is required")
	}

	return nil
}

type InitializeParams struct {
	_InitializeParams
	WorkspaceFoldersInitializeParams
}

func (x *InitializeParams) UnmarshalJSON(data []byte) error {
	type plain InitializeParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The result returned from an initialize request.
type InitializeResult struct {
	// The capabilities the language server provides.
	Capabilities ServerCapabilities `json:"capabilities"`
	// Information about the server.
	//
	// @since 3.15.0
	ServerInfo *InitializeResultServerInfo `json:"serverInfo,omitempty"`
}

func (x *InitializeResult) UnmarshalJSON(data []byte) error {
	type plain InitializeResult
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Capabilities

	return nil
}

type InitializeResultServerInfo struct {
	// The name of the server as defined by the server.
	Name string `json:"name"`
	// The server's version as defined by the server.
	Version string `json:"version,omitempty"`
}

func (x *InitializeResultServerInfo) UnmarshalJSON(data []byte) error {
	type plain InitializeResultServerInfo
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Name == "" {
		return errors.New("\"name\" property is required")
	}

	return nil
}

type InitializedParams struct{}

func (x *InitializedParams) UnmarshalJSON(data []byte) error {
	type plain InitializedParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Inlay hint information.
//
// @since 3.17.0
type InlayHint struct {
	// The position of this hint.
	Position Position `json:"position"`
	// The label of this hint. A human readable string or an array of
	// InlayHintLabelPart label parts.
	//
	// *Note* that neither the string nor the label part can be empty.
	Label OneOf2[string, []InlayHintLabelPart] `json:"label"`
	// The kind of this hint. Can be omitted in which case the client
	// should fall back to a reasonable default.
	Kind InlayHintKind `json:"kind,omitempty"`
	// Optional text edits that are performed when accepting this inlay hint.
	//
	// *Note* that edits are expected to change the document so that the inlay
	// hint (or its nearest variant) is now part of the document and the inlay
	// hint itself is now obsolete.
	TextEdits []TextEdit `json:"textEdits,omitempty"`
	// The tooltip text when you hover over this item.
	Tooltip *OneOf2[string, MarkupContent] `json:"tooltip,omitempty"`
	// Render padding before the hint.
	//
	// Note: Padding should use the editor's background color, not the
	// background color of the hint itself. That means padding can be used
	// to visually align/separate an inlay hint.
	PaddingLeft bool `json:"paddingLeft,omitempty"`
	// Render padding after the hint.
	//
	// Note: Padding should use the editor's background color, not the
	// background color of the hint itself. That means padding can be used
	// to visually align/separate an inlay hint.
	PaddingRight bool `json:"paddingRight,omitempty"`
	// A data entry field that is preserved on an inlay hint between
	// a `textDocument/inlayHint` and a `inlayHint/resolve` request.
	Data any `json:"data,omitempty"`
}

func (x *InlayHint) UnmarshalJSON(data []byte) error {
	type plain InlayHint
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Position

	var _ json.Unmarshaler = &x.Label

	return nil
}

// Inlay hint client capabilities.
//
// @since 3.17.0
type InlayHintClientCapabilities struct {
	// Whether inlay hints support dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Indicates which properties a client can resolve lazily on an inlay
	// hint.
	ResolveSupport *InlayHintClientCapabilitiesResolveSupport `json:"resolveSupport,omitempty"`
}

func (x *InlayHintClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain InlayHintClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type InlayHintClientCapabilitiesResolveSupport struct {
	// The properties that a client can resolve lazily.
	Properties []string `json:"properties"`
}

func (x *InlayHintClientCapabilitiesResolveSupport) UnmarshalJSON(data []byte) error {
	type plain InlayHintClientCapabilitiesResolveSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Properties == nil {
		return errors.New("\"properties\" property is required")
	}

	return nil
}

// An inlay hint label part allows for interactive and composite labels
// of inlay hints.
//
// @since 3.17.0
type InlayHintLabelPart struct {
	// The value of this label part.
	Value string `json:"value"`
	// The tooltip text when you hover over this label part. Depending on
	// the client capability `inlayHint.resolveSupport` clients might resolve
	// this property late using the resolve request.
	Tooltip *OneOf2[string, MarkupContent] `json:"tooltip,omitempty"`
	// An optional source code location that represents this
	// label part.
	//
	// The editor will use this location for the hover and for code navigation
	// features: This part will become a clickable link that resolves to the
	// definition of the symbol at the given location (not necessarily the
	// location itself), it shows the hover that shows at the given location,
	// and it shows a context menu with further code navigation commands.
	//
	// Depending on the client capability `inlayHint.resolveSupport` clients
	// might resolve this property late using the resolve request.
	Location *Location `json:"location,omitempty"`
	// An optional command for this label part.
	//
	// Depending on the client capability `inlayHint.resolveSupport` clients
	// might resolve this property late using the resolve request.
	Command *Command `json:"command,omitempty"`
}

func (x *InlayHintLabelPart) UnmarshalJSON(data []byte) error {
	type plain InlayHintLabelPart
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Value == "" {
		return errors.New("\"value\" property is required")
	}

	return nil
}

// Inlay hint options used during static registration.
//
// @since 3.17.0
type InlayHintOptions struct {
	WorkDoneProgressOptions
	// The server provides support to resolve additional
	// information for an inlay hint item.
	ResolveProvider bool `json:"resolveProvider,omitempty"`
}

func (x *InlayHintOptions) UnmarshalJSON(data []byte) error {
	type plain InlayHintOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A parameter literal used in inlay hint requests.
//
// @since 3.17.0
type InlayHintParams struct {
	WorkDoneProgressParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The document range for which inlay hints should be computed.
	Range Range `json:"range"`
}

func (x *InlayHintParams) UnmarshalJSON(data []byte) error {
	type plain InlayHintParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	var _ json.Unmarshaler = &x.Range

	return nil
}

// Inlay hint options used during static or dynamic registration.
//
// @since 3.17.0
type InlayHintRegistrationOptions struct {
	InlayHintOptions
	TextDocumentRegistrationOptions
	StaticRegistrationOptions
}

func (x *InlayHintRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain InlayHintRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Client workspace capabilities specific to inlay hints.
//
// @since 3.17.0
type InlayHintWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from
	// the server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// inlay hints currently shown. It should be used with absolute care and
	// is useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

func (x *InlayHintWorkspaceClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain InlayHintWorkspaceClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Client capabilities specific to inline values.
//
// @since 3.17.0
type InlineValueClientCapabilities struct {
	// Whether implementation supports dynamic registration for inline value providers.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *InlineValueClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain InlineValueClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// @since 3.17.0
type InlineValueContext struct {
	// The stack frame (as a DAP Id) where the execution has stopped.
	FrameId int32 `json:"frameId"`
	// The document range where execution has stopped.
	// Typically the end position of the range denotes the line where the inline values are shown.
	StoppedLocation Range `json:"stoppedLocation"`
}

func (x *InlineValueContext) UnmarshalJSON(data []byte) error {
	type plain InlineValueContext
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.FrameId == 0 {
		return errors.New("\"frameId\" property is required")
	}

	var _ json.Unmarshaler = &x.StoppedLocation

	return nil
}

// Provide an inline value through an expression evaluation.
// If only a range is specified, the expression will be extracted from the underlying document.
// An optional expression can be used to override the extracted expression.
//
// @since 3.17.0
type InlineValueEvaluatableExpression struct {
	// The document range for which the inline value applies.
	// The range is used to extract the evaluatable expression from the underlying document.
	Range Range `json:"range"`
	// If specified the expression overrides the extracted expression.
	Expression string `json:"expression,omitempty"`
}

func (x *InlineValueEvaluatableExpression) UnmarshalJSON(data []byte) error {
	type plain InlineValueEvaluatableExpression
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	return nil
}

// Inline value options used during static registration.
//
// @since 3.17.0
type InlineValueOptions struct {
	WorkDoneProgressOptions
}

func (x *InlineValueOptions) UnmarshalJSON(data []byte) error {
	type plain InlineValueOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A parameter literal used in inline value requests.
//
// @since 3.17.0
type InlineValueParams struct {
	WorkDoneProgressParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The document range for which inline values should be computed.
	Range Range `json:"range"`
	// Additional information about the context in which inline values were
	// requested.
	Context InlineValueContext `json:"context"`
}

func (x *InlineValueParams) UnmarshalJSON(data []byte) error {
	type plain InlineValueParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	var _ json.Unmarshaler = &x.Range

	var _ json.Unmarshaler = &x.Context

	return nil
}

// Inline value options used during static or dynamic registration.
//
// @since 3.17.0
type InlineValueRegistrationOptions struct {
	InlineValueOptions
	TextDocumentRegistrationOptions
	StaticRegistrationOptions
}

func (x *InlineValueRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain InlineValueRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Provide inline value as text.
//
// @since 3.17.0
type InlineValueText struct {
	// The document range for which the inline value applies.
	Range Range `json:"range"`
	// The text of the inline value.
	Text string `json:"text"`
}

func (x *InlineValueText) UnmarshalJSON(data []byte) error {
	type plain InlineValueText
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	if x.Text == "" {
		return errors.New("\"text\" property is required")
	}

	return nil
}

// Provide inline value through a variable lookup.
// If only a range is specified, the variable name will be extracted from the underlying document.
// An optional variable name can be used to override the extracted name.
//
// @since 3.17.0
type InlineValueVariableLookup struct {
	// The document range for which the inline value applies.
	// The range is used to extract the variable name from the underlying document.
	Range Range `json:"range"`
	// If specified the name of the variable to look up.
	VariableName string `json:"variableName,omitempty"`
	// How to perform the lookup.
	CaseSensitiveLookup bool `json:"caseSensitiveLookup"`
}

func (x *InlineValueVariableLookup) UnmarshalJSON(data []byte) error {
	type plain InlineValueVariableLookup
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	if x.CaseSensitiveLookup == false {
		return errors.New("\"caseSensitiveLookup\" property is required")
	}

	return nil
}

// Client workspace capabilities specific to inline values.
//
// @since 3.17.0
type InlineValueWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from the
	// server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// inline values currently shown. It should be used with absolute care and is
	// useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

func (x *InlineValueWorkspaceClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain InlineValueWorkspaceClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A special text edit to provide an insert and a replace operation.
//
// @since 3.16.0
type InsertReplaceEdit struct {
	// The string to be inserted.
	NewText string `json:"newText"`
	// The range if the insert is requested
	Insert Range `json:"insert"`
	// The range if the replace is requested.
	Replace Range `json:"replace"`
}

func (x *InsertReplaceEdit) UnmarshalJSON(data []byte) error {
	type plain InsertReplaceEdit
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.NewText == "" {
		return errors.New("\"newText\" property is required")
	}

	var _ json.Unmarshaler = &x.Insert

	var _ json.Unmarshaler = &x.Replace

	return nil
}

// Client capabilities for the linked editing range request.
//
// @since 3.16.0
type LinkedEditingRangeClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *LinkedEditingRangeClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain LinkedEditingRangeClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type LinkedEditingRangeOptions struct {
	WorkDoneProgressOptions
}

func (x *LinkedEditingRangeOptions) UnmarshalJSON(data []byte) error {
	type plain LinkedEditingRangeOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type LinkedEditingRangeParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
}

func (x *LinkedEditingRangeParams) UnmarshalJSON(data []byte) error {
	type plain LinkedEditingRangeParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type LinkedEditingRangeRegistrationOptions struct {
	TextDocumentRegistrationOptions
	LinkedEditingRangeOptions
	StaticRegistrationOptions
}

func (x *LinkedEditingRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain LinkedEditingRangeRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The result of a linked editing range request.
//
// @since 3.16.0
type LinkedEditingRanges struct {
	// A list of ranges that can be edited together. The ranges must have
	// identical length and contain identical text content. The ranges cannot overlap.
	Ranges []Range `json:"ranges"`
	// An optional word pattern (regular expression) that describes valid contents for
	// the given ranges. If no pattern is provided, the client configuration's word
	// pattern will be used.
	WordPattern string `json:"wordPattern,omitempty"`
}

func (x *LinkedEditingRanges) UnmarshalJSON(data []byte) error {
	type plain LinkedEditingRanges
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Ranges == nil {
		return errors.New("\"ranges\" property is required")
	}

	return nil
}

// Represents a location inside a resource, such as a line
// inside a text file.
type Location struct {
	URI   DocumentURI `json:"uri"`
	Range Range       `json:"range"`
}

func (x *Location) UnmarshalJSON(data []byte) error {
	type plain Location
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	var _ json.Unmarshaler = &x.Range

	return nil
}

// Represents the connection of two locations. Provides additional metadata over normal {@link Location locations},
// including an origin range.
type LocationLink struct {
	// Span of the origin of this link.
	//
	// Used as the underlined span for mouse interaction. Defaults to the word range at
	// the definition position.
	OriginSelectionRange *Range `json:"originSelectionRange,omitempty"`
	// The target resource identifier of this link.
	TargetURI DocumentURI `json:"targetUri"`
	// The full target range of this link. If the target for example is a symbol then target range is the
	// range enclosing this symbol not including leading/trailing whitespace but everything else
	// like comments. This information is typically used to highlight the range in the editor.
	TargetRange Range `json:"targetRange"`
	// The range that should be selected and revealed when this link is being followed, e.g the name of a function.
	// Must be contained by the `targetRange`. See also `DocumentSymbol#range`
	TargetSelectionRange Range `json:"targetSelectionRange"`
}

func (x *LocationLink) UnmarshalJSON(data []byte) error {
	type plain LocationLink
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.TargetURI == (DocumentURI{}) {
		return errors.New("\"targetUri\" property is required")
	}

	var _ json.Unmarshaler = &x.TargetRange

	var _ json.Unmarshaler = &x.TargetSelectionRange

	return nil
}

// The log message parameters.
type LogMessageParams struct {
	// The message type. See {@link MessageType}
	Type MessageType `json:"type"`
	// The actual message.
	Message string `json:"message"`
}

func (x *LogMessageParams) UnmarshalJSON(data []byte) error {
	type plain LogMessageParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Type == 0 {
		return errors.New("\"type\" property is required")
	}

	if x.Message == "" {
		return errors.New("\"message\" property is required")
	}

	return nil
}

type LogTraceParams struct {
	Message string `json:"message"`
	Verbose string `json:"verbose,omitempty"`
}

func (x *LogTraceParams) UnmarshalJSON(data []byte) error {
	type plain LogTraceParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Message == "" {
		return errors.New("\"message\" property is required")
	}

	return nil
}

// Client capabilities specific to the used markdown parser.
//
// @since 3.16.0
type MarkdownClientCapabilities struct {
	// The name of the parser.
	Parser string `json:"parser"`
	// The version of the parser.
	Version string `json:"version,omitempty"`
	// A list of HTML tags that the client allows / supports in
	// Markdown.
	//
	// @since 3.17.0
	AllowedTags []string `json:"allowedTags,omitempty"`
}

func (x *MarkdownClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain MarkdownClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Parser == "" {
		return errors.New("\"parser\" property is required")
	}

	return nil
}

// A `MarkupContent` literal represents a string value which content is interpreted base on its
// kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.
//
// If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.
// See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
//
// Here is an example how such a string can be constructed using JavaScript / TypeScript:
// ```ts
//
//	let markdown: MarkdownContent = {
//	 kind: MarkupKind.Markdown,
//	 value: [
//	   '# Header',
//	   'Some text',
//	   '```typescript',
//	   'someCode();',
//	   '```'
//	 ].join('\n')
//	};
//
// ```
//
// *Please Note* that clients might sanitize the return markdown. A client could decide to
// remove HTML from the markdown to avoid script execution.
type MarkupContent struct {
	// The type of the Markup
	Kind MarkupKind `json:"kind"`
	// The content itself
	Value string `json:"value"`
}

func (x *MarkupContent) UnmarshalJSON(data []byte) error {
	type plain MarkupContent
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Kind == "" {
		return errors.New("\"kind\" property is required")
	}

	if x.Value == "" {
		return errors.New("\"value\" property is required")
	}

	return nil
}

type MessageActionItem struct {
	// A short title like 'Retry', 'Open Log' etc.
	Title string `json:"title"`
}

func (x *MessageActionItem) UnmarshalJSON(data []byte) error {
	type plain MessageActionItem
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Title == "" {
		return errors.New("\"title\" property is required")
	}

	return nil
}

// Moniker definition to match LSIF 0.5 moniker definition.
//
// @since 3.16.0
type Moniker struct {
	// The scheme of the moniker. For example tsc or .Net
	Scheme string `json:"scheme"`
	// The identifier of the moniker. The value is opaque in LSIF however
	// schema owners are allowed to define the structure if they want.
	Identifier string `json:"identifier"`
	// The scope in which the moniker is unique
	Unique UniquenessLevel `json:"unique"`
	// The moniker kind if known.
	Kind MonikerKind `json:"kind,omitempty"`
}

func (x *Moniker) UnmarshalJSON(data []byte) error {
	type plain Moniker
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Scheme == "" {
		return errors.New("\"scheme\" property is required")
	}

	if x.Identifier == "" {
		return errors.New("\"identifier\" property is required")
	}

	if x.Unique == "" {
		return errors.New("\"unique\" property is required")
	}

	return nil
}

// Client capabilities specific to the moniker request.
//
// @since 3.16.0
type MonikerClientCapabilities struct {
	// Whether moniker supports dynamic registration. If this is set to `true`
	// the client supports the new `MonikerRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *MonikerClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain MonikerClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type MonikerOptions struct {
	WorkDoneProgressOptions
}

func (x *MonikerOptions) UnmarshalJSON(data []byte) error {
	type plain MonikerOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type MonikerParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
	PartialResultParams
}

func (x *MonikerParams) UnmarshalJSON(data []byte) error {
	type plain MonikerParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type MonikerRegistrationOptions struct {
	TextDocumentRegistrationOptions
	MonikerOptions
}

func (x *MonikerRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain MonikerRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A notebook cell.
//
// A cell's document URI must be unique across ALL notebook
// cells and can therefore be used to uniquely identify a
// notebook cell or the cell's text document.
//
// @since 3.17.0
type NotebookCell struct {
	// The cell's kind
	Kind NotebookCellKind `json:"kind"`
	// The URI of the cell's text document
	// content.
	Document DocumentURI `json:"document"`
	// Additional metadata stored with the cell.
	//
	// Note: should always be an object literal (e.g. LSPObject)
	Metadata map[string]any `json:"metadata,omitempty"`
	// Additional execution summary information
	// if supported by the client.
	ExecutionSummary *ExecutionSummary `json:"executionSummary,omitempty"`
}

func (x *NotebookCell) UnmarshalJSON(data []byte) error {
	type plain NotebookCell
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Kind == 0 {
		return errors.New("\"kind\" property is required")
	}

	if x.Document == (DocumentURI{}) {
		return errors.New("\"document\" property is required")
	}

	return nil
}

// A change describing how to move a `NotebookCell`
// array from state S to S'.
//
// @since 3.17.0
type NotebookCellArrayChange struct {
	// The start oftest of the cell that changed.
	Start uint32 `json:"start"`
	// The deleted cells
	DeleteCount uint32 `json:"deleteCount"`
	// The new cells, if any
	Cells []NotebookCell `json:"cells,omitempty"`
}

func (x *NotebookCellArrayChange) UnmarshalJSON(data []byte) error {
	type plain NotebookCellArrayChange
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Start == 0 {
		return errors.New("\"start\" property is required")
	}

	if x.DeleteCount == 0 {
		return errors.New("\"deleteCount\" property is required")
	}

	return nil
}

// A notebook cell text document filter denotes a cell text
// document by different properties.
//
// @since 3.17.0
type NotebookCellTextDocumentFilter struct {
	// A filter that matches against the notebook
	// containing the notebook cell. If a string
	// value is provided it matches against the
	// notebook type. '*' matches every notebook.
	Notebook OneOf2[string, NotebookDocumentFilter] `json:"notebook"`
	// A language id like `python`.
	//
	// Will be matched against the language id of the
	// notebook cell document. '*' matches every language.
	Language string `json:"language,omitempty"`
}

func (x *NotebookCellTextDocumentFilter) UnmarshalJSON(data []byte) error {
	type plain NotebookCellTextDocumentFilter
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Notebook

	return nil
}

// A notebook document.
//
// @since 3.17.0
type NotebookDocument struct {
	// The notebook document's uri.
	URI URI `json:"uri"`
	// The type of the notebook.
	NotebookType string `json:"notebookType"`
	// The version number of this document (it will increase after each
	// change, including undo/redo).
	Version int32 `json:"version"`
	// Additional metadata stored with the notebook
	// document.
	//
	// Note: should always be an object literal (e.g. LSPObject)
	Metadata map[string]any `json:"metadata,omitempty"`
	// The cells of a notebook.
	Cells []NotebookCell `json:"cells"`
}

func (x *NotebookDocument) UnmarshalJSON(data []byte) error {
	type plain NotebookDocument
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (URI{}) {
		return errors.New("\"uri\" property is required")
	}

	if x.NotebookType == "" {
		return errors.New("\"notebookType\" property is required")
	}

	if x.Version == 0 {
		return errors.New("\"version\" property is required")
	}

	if x.Cells == nil {
		return errors.New("\"cells\" property is required")
	}

	return nil
}

// A change event for a notebook document.
//
// @since 3.17.0
type NotebookDocumentChangeEvent struct {
	// The changed meta data if any.
	//
	// Note: should always be an object literal (e.g. LSPObject)
	Metadata map[string]any `json:"metadata,omitempty"`
	// Changes to cells
	Cells *NotebookDocumentChangeEventCells `json:"cells,omitempty"`
}

func (x *NotebookDocumentChangeEvent) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentChangeEvent
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type NotebookDocumentChangeEventCellsStructure struct {
	// The change to the cell array.
	Array NotebookCellArrayChange `json:"array"`
	// Additional opened cell text documents.
	DidOpen []TextDocumentItem `json:"didOpen,omitempty"`
	// Additional closed cell text documents.
	DidClose []TextDocumentIdentifier `json:"didClose,omitempty"`
}

func (x *NotebookDocumentChangeEventCellsStructure) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentChangeEventCellsStructure
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Array

	return nil
}

type NotebookDocumentChangeEventCellsTextContent struct {
	Document VersionedTextDocumentIdentifier  `json:"document"`
	Changes  []TextDocumentContentChangeEvent `json:"changes"`
}

func (x *NotebookDocumentChangeEventCellsTextContent) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentChangeEventCellsTextContent
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Document

	if x.Changes == nil {
		return errors.New("\"changes\" property is required")
	}

	return nil
}

type NotebookDocumentChangeEventCells struct {
	// Changes to the cell structure to add or
	// remove cells.
	Structure *NotebookDocumentChangeEventCellsStructure `json:"structure,omitempty"`
	// Changes to notebook cells properties like its
	// kind, execution summary or metadata.
	Data []NotebookCell `json:"data,omitempty"`
	// Changes to the text content of notebook cells.
	TextContent []NotebookDocumentChangeEventCellsTextContent `json:"textContent,omitempty"`
}

func (x *NotebookDocumentChangeEventCells) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentChangeEventCells
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Capabilities specific to the notebook document support.
//
// @since 3.17.0
type NotebookDocumentClientCapabilities struct {
	// Capabilities specific to notebook document synchronization
	//
	// @since 3.17.0
	Synchronization NotebookDocumentSyncClientCapabilities `json:"synchronization"`
}

func (x *NotebookDocumentClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Synchronization

	return nil
}

// A literal to identify a notebook document in the client.
//
// @since 3.17.0
type NotebookDocumentIdentifier struct {
	// The notebook document's uri.
	URI URI `json:"uri"`
}

func (x *NotebookDocumentIdentifier) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentIdentifier
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (URI{}) {
		return errors.New("\"uri\" property is required")
	}

	return nil
}

// Notebook specific client capabilities.
//
// @since 3.17.0
type NotebookDocumentSyncClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is
	// set to `true` the client supports the new
	// `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports sending execution summary data per cell.
	ExecutionSummarySupport bool `json:"executionSummarySupport,omitempty"`
}

func (x *NotebookDocumentSyncClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentSyncClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Options specific to a notebook plus its cells
// to be synced to the server.
//
// If a selector provides a notebook document
// filter but no cell selector all cells of a
// matching notebook document will be synced.
//
// If a selector provides no notebook document
// filter but only a cell selector all notebook
// document that contain at least one matching
// cell will be synced.
//
// @since 3.17.0
type NotebookDocumentSyncOptions struct {
	// The notebooks to be synced
	NotebookSelector []OneOf2[NotebookDocumentSyncOptionsNotebookSelector, NotebookDocumentSyncOptionsNotebookSelector1] `json:"notebookSelector"`
	// Whether save notification should be forwarded to
	// the server. Will only be honored if mode === `notebook`.
	Save bool `json:"save,omitempty"`
}

func (x *NotebookDocumentSyncOptions) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentSyncOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.NotebookSelector == nil {
		return errors.New("\"notebookSelector\" property is required")
	}

	return nil
}

type NotebookDocumentSyncOptionsNotebookSelectorCells struct {
	Language string `json:"language"`
}

func (x *NotebookDocumentSyncOptionsNotebookSelectorCells) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentSyncOptionsNotebookSelectorCells
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Language == "" {
		return errors.New("\"language\" property is required")
	}

	return nil
}

type NotebookDocumentSyncOptionsNotebookSelector struct {
	// The notebook to be synced If a string
	// value is provided it matches against the
	// notebook type. '*' matches every notebook.
	Notebook OneOf2[string, NotebookDocumentFilter] `json:"notebook"`
	// The cells of the matching notebook to be synced.
	Cells []NotebookDocumentSyncOptionsNotebookSelectorCells `json:"cells,omitempty"`
}

func (x *NotebookDocumentSyncOptionsNotebookSelector) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentSyncOptionsNotebookSelector
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Notebook

	return nil
}

type NotebookDocumentSyncOptionsNotebookSelector1Cells struct {
	Language string `json:"language"`
}

func (x *NotebookDocumentSyncOptionsNotebookSelector1Cells) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentSyncOptionsNotebookSelector1Cells
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Language == "" {
		return errors.New("\"language\" property is required")
	}

	return nil
}

type NotebookDocumentSyncOptionsNotebookSelector1 struct {
	// The notebook to be synced If a string
	// value is provided it matches against the
	// notebook type. '*' matches every notebook.
	Notebook *OneOf2[string, NotebookDocumentFilter] `json:"notebook,omitempty"`
	// The cells of the matching notebook to be synced.
	Cells []NotebookDocumentSyncOptionsNotebookSelector1Cells `json:"cells"`
}

func (x *NotebookDocumentSyncOptionsNotebookSelector1) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentSyncOptionsNotebookSelector1
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Cells == nil {
		return errors.New("\"cells\" property is required")
	}

	return nil
}

// Registration options specific to a notebook.
//
// @since 3.17.0
type NotebookDocumentSyncRegistrationOptions struct {
	NotebookDocumentSyncOptions
	StaticRegistrationOptions
}

func (x *NotebookDocumentSyncRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentSyncRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A text document identifier to optionally denote a specific version of a text document.
type OptionalVersionedTextDocumentIdentifier struct {
	TextDocumentIdentifier
	// The version number of this document. If a versioned text document identifier
	// is sent from the server to the client and the file is not open in the editor
	// (the server has not received an open notification before) the server can send
	// `null` to indicate that the version is unknown and the content on disk is the
	// truth (as specified with document content ownership).
	Version int32 `json:"version"`
}

func (x *OptionalVersionedTextDocumentIdentifier) UnmarshalJSON(data []byte) error {
	type plain OptionalVersionedTextDocumentIdentifier
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Version == 0 {
		return errors.New("\"version\" property is required")
	}

	return nil
}

// Represents a parameter of a callable-signature. A parameter can
// have a label and a doc-comment.
type ParameterInformation struct {
	// The label of this parameter information.
	//
	// Either a string or an inclusive start and exclusive end offsets within its containing
	// signature label. (see SignatureInformation.label). The offsets are based on a UTF-16
	// string representation as `Position` and `Range` does.
	//
	// *Note*: a label of type string should be a substring of its containing signature label.
	// Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`.
	Label OneOf2[string, [2]uint32] `json:"label"`
	// The human-readable doc-comment of this parameter. Will be shown
	// in the UI but can be omitted.
	Documentation *OneOf2[string, MarkupContent] `json:"documentation,omitempty"`
}

func (x *ParameterInformation) UnmarshalJSON(data []byte) error {
	type plain ParameterInformation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Label

	return nil
}

type PartialResultParams struct {
	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *ProgressToken `json:"partialResultToken,omitempty"`
}

func (x *PartialResultParams) UnmarshalJSON(data []byte) error {
	type plain PartialResultParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Position in a text document expressed as zero-based line and character
// offset. Prior to 3.17 the offsets were always based on a UTF-16 string
// representation. So a string of the form `a𐐀b` the character offset of the
// character `a` is 0, the character offset of `𐐀` is 1 and the character
// offset of b is 3 since `𐐀` is represented using two code units in UTF-16.
// Since 3.17 clients and servers can agree on a different string encoding
// representation (e.g. UTF-8). The client announces it's supported encoding
// via the client capability [`general.positionEncodings`](#clientCapabilities).
// The value is an array of position encodings the client supports, with
// decreasing preference (e.g. the encoding at index `0` is the most preferred
// one). To stay backwards compatible the only mandatory encoding is UTF-16
// represented via the string `utf-16`. The server can pick one of the
// encodings offered by the client and signals that encoding back to the
// client via the initialize result's property
// [`capabilities.positionEncoding`](#serverCapabilities). If the string value
// `utf-16` is missing from the client's capability `general.positionEncodings`
// servers can safely assume that the client supports UTF-16. If the server
// omits the position encoding in its initialize result the encoding defaults
// to the string value `utf-16`. Implementation considerations: since the
// conversion from one encoding into another requires the content of the
// file / line the conversion is best done where the file is read which is
// usually on the server side.
//
// Positions are line end character agnostic. So you can not specify a position
// that denotes `\r|\n` or `\n|` where `|` represents the character offset.
//
// @since 3.17.0 - support for negotiated position encoding.
type Position struct {
	// Line position in a document (zero-based).
	//
	// If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the document.
	// If a line number is negative, it defaults to 0.
	Line uint32 `json:"line"`
	// Character offset on a line in a document (zero-based).
	//
	// The meaning of this offset is determined by the negotiated
	// `PositionEncodingKind`.
	//
	// If the character value is greater than the line length it defaults back to the
	// line length.
	Character uint32 `json:"character"`
}

func (x *Position) UnmarshalJSON(data []byte) error {
	type plain Position
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Line == 0 {
		return errors.New("\"line\" property is required")
	}

	if x.Character == 0 {
		return errors.New("\"character\" property is required")
	}

	return nil
}

type PrepareRenameParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
}

func (x *PrepareRenameParams) UnmarshalJSON(data []byte) error {
	type plain PrepareRenameParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A previous result id in a workspace pull request.
//
// @since 3.17.0
type PreviousResultId struct {
	// The URI for which the client knowns a
	// result id.
	URI DocumentURI `json:"uri"`
	// The value of the previous result id.
	Value string `json:"value"`
}

func (x *PreviousResultId) UnmarshalJSON(data []byte) error {
	type plain PreviousResultId
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	if x.Value == "" {
		return errors.New("\"value\" property is required")
	}

	return nil
}

type ProgressParams struct {
	// The progress token provided by the client or server.
	Token ProgressToken `json:"token"`
	// The progress data.
	Value any `json:"value"`
}

func (x *ProgressParams) UnmarshalJSON(data []byte) error {
	type plain ProgressParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Token

	if x.Value == nil {
		return errors.New("\"value\" property is required")
	}

	return nil
}

// The publish diagnostic client capabilities.
type PublishDiagnosticsClientCapabilities struct {
	// Whether the clients accepts diagnostics with related information.
	RelatedInformation bool `json:"relatedInformation,omitempty"`
	// Client supports the tag property to provide meta data about a diagnostic.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// @since 3.15.0
	TagSupport *PublishDiagnosticsClientCapabilitiesTagSupport `json:"tagSupport,omitempty"`
	// Whether the client interprets the version property of the
	// `textDocument/publishDiagnostics` notification's parameter.
	//
	// @since 3.15.0
	VersionSupport bool `json:"versionSupport,omitempty"`
	// Client supports a codeDescription property
	//
	// @since 3.16.0
	CodeDescriptionSupport bool `json:"codeDescriptionSupport,omitempty"`
	// Whether code action supports the `data` property which is
	// preserved between a `textDocument/publishDiagnostics` and
	// `textDocument/codeAction` request.
	//
	// @since 3.16.0
	DataSupport bool `json:"dataSupport,omitempty"`
}

func (x *PublishDiagnosticsClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain PublishDiagnosticsClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type PublishDiagnosticsClientCapabilitiesTagSupport struct {
	// The tags supported by the client.
	ValueSet []DiagnosticTag `json:"valueSet"`
}

func (x *PublishDiagnosticsClientCapabilitiesTagSupport) UnmarshalJSON(data []byte) error {
	type plain PublishDiagnosticsClientCapabilitiesTagSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.ValueSet == nil {
		return errors.New("\"valueSet\" property is required")
	}

	return nil
}

// The publish diagnostic notification's parameters.
type PublishDiagnosticsParams struct {
	// The URI for which diagnostic information is reported.
	URI DocumentURI `json:"uri"`
	// Optional the version number of the document the diagnostics are published for.
	//
	// @since 3.15.0
	Version int32 `json:"version,omitempty"`
	// An array of diagnostic information items.
	Diagnostics []Diagnostic `json:"diagnostics"`
}

func (x *PublishDiagnosticsParams) UnmarshalJSON(data []byte) error {
	type plain PublishDiagnosticsParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	if x.Diagnostics == nil {
		return errors.New("\"diagnostics\" property is required")
	}

	return nil
}

// A range in a text document expressed as (zero-based) start and end positions.
//
// If you want to specify a range that contains a line including the line ending
// character(s) then use an end position denoting the start of the next line.
// For example:
// ```ts
//
//	{
//	    start: { line: 5, character: 23 }
//	    end : { line 6, character : 0 }
//	}
//
// ```
type Range struct {
	// The range's start position.
	Start Position `json:"start"`
	// The range's end position.
	End Position `json:"end"`
}

func (x *Range) UnmarshalJSON(data []byte) error {
	type plain Range
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Start

	var _ json.Unmarshaler = &x.End

	return nil
}

// Client Capabilities for a {@link ReferencesRequest}.
type ReferenceClientCapabilities struct {
	// Whether references supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *ReferenceClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain ReferenceClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Value-object that contains additional information when
// requesting references.
type ReferenceContext struct {
	// Include the declaration of the current symbol.
	IncludeDeclaration bool `json:"includeDeclaration"`
}

func (x *ReferenceContext) UnmarshalJSON(data []byte) error {
	type plain ReferenceContext
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.IncludeDeclaration == false {
		return errors.New("\"includeDeclaration\" property is required")
	}

	return nil
}

// Reference options.
type ReferenceOptions struct {
	WorkDoneProgressOptions
}

func (x *ReferenceOptions) UnmarshalJSON(data []byte) error {
	type plain ReferenceOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Parameters for a {@link ReferencesRequest}.
type ReferenceParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
	PartialResultParams
	Context ReferenceContext `json:"context"`
}

func (x *ReferenceParams) UnmarshalJSON(data []byte) error {
	type plain ReferenceParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Context

	return nil
}

// Registration options for a {@link ReferencesRequest}.
type ReferenceRegistrationOptions struct {
	TextDocumentRegistrationOptions
	ReferenceOptions
}

func (x *ReferenceRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain ReferenceRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// General parameters to to register for an notification or to register a provider.
type Registration struct {
	// The id used to register the request. The id can be used to deregister
	// the request again.
	Id string `json:"id"`
	// The method / capability to register for.
	Method string `json:"method"`
	// Options necessary for the registration.
	RegisterOptions any `json:"registerOptions,omitempty"`
}

func (x *Registration) UnmarshalJSON(data []byte) error {
	type plain Registration
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Id == "" {
		return errors.New("\"id\" property is required")
	}

	if x.Method == "" {
		return errors.New("\"method\" property is required")
	}

	return nil
}

type RegistrationParams struct {
	Registrations []Registration `json:"registrations"`
}

func (x *RegistrationParams) UnmarshalJSON(data []byte) error {
	type plain RegistrationParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Registrations == nil {
		return errors.New("\"registrations\" property is required")
	}

	return nil
}

// Client capabilities specific to regular expressions.
//
// @since 3.16.0
type RegularExpressionsClientCapabilities struct {
	// The engine's name.
	Engine string `json:"engine"`
	// The engine's version.
	Version string `json:"version,omitempty"`
}

func (x *RegularExpressionsClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain RegularExpressionsClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Engine == "" {
		return errors.New("\"engine\" property is required")
	}

	return nil
}

// A full diagnostic report with a set of related documents.
//
// @since 3.17.0
type RelatedFullDocumentDiagnosticReport struct {
	FullDocumentDiagnosticReport
	// Diagnostics of related documents. This information is useful
	// in programming languages where code in a file A can generate
	// diagnostics in a file B which A depends on. An example of
	// such a language is C/C++ where marco definitions in a file
	// a.cpp and result in errors in a header file b.hpp.
	//
	// @since 3.17.0
	RelatedDocuments map[DocumentURI]OneOf2[FullDocumentDiagnosticReport, UnchangedDocumentDiagnosticReport] `json:"relatedDocuments,omitempty"`
}

func (x *RelatedFullDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	type plain RelatedFullDocumentDiagnosticReport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// An unchanged diagnostic report with a set of related documents.
//
// @since 3.17.0
type RelatedUnchangedDocumentDiagnosticReport struct {
	UnchangedDocumentDiagnosticReport
	// Diagnostics of related documents. This information is useful
	// in programming languages where code in a file A can generate
	// diagnostics in a file B which A depends on. An example of
	// such a language is C/C++ where marco definitions in a file
	// a.cpp and result in errors in a header file b.hpp.
	//
	// @since 3.17.0
	RelatedDocuments map[DocumentURI]OneOf2[FullDocumentDiagnosticReport, UnchangedDocumentDiagnosticReport] `json:"relatedDocuments,omitempty"`
}

func (x *RelatedUnchangedDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	type plain RelatedUnchangedDocumentDiagnosticReport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A relative pattern is a helper to construct glob patterns that are matched
// relatively to a base URI. The common value for a `baseUri` is a workspace
// folder root, but it can be another absolute URI as well.
//
// @since 3.17.0
type RelativePattern struct {
	// A workspace folder or a base URI to which this pattern will be matched
	// against relatively.
	BaseURI OneOf2[WorkspaceFolder, URI] `json:"baseUri"`
	// The actual glob pattern;
	Pattern Pattern `json:"pattern"`
}

func (x *RelativePattern) UnmarshalJSON(data []byte) error {
	type plain RelativePattern
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.BaseURI

	if x.Pattern == "" {
		return errors.New("\"pattern\" property is required")
	}

	return nil
}

type RenameClientCapabilities struct {
	// Whether rename supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Client supports testing for validity of rename operations
	// before execution.
	//
	// @since 3.12.0
	PrepareSupport bool `json:"prepareSupport,omitempty"`
	// Client supports the default behavior result.
	//
	// The value indicates the default behavior used by the
	// client.
	//
	// @since 3.16.0
	PrepareSupportDefaultBehavior PrepareSupportDefaultBehavior `json:"prepareSupportDefaultBehavior,omitempty"`
	// Whether the client honors the change annotations in
	// text edits and resource operations returned via the
	// rename request's workspace edit by for example presenting
	// the workspace edit in the user interface and asking
	// for confirmation.
	//
	// @since 3.16.0
	HonorsChangeAnnotations bool `json:"honorsChangeAnnotations,omitempty"`
}

func (x *RenameClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain RenameClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Rename file operation
type RenameFile struct {
	ResourceOperation
	// A rename
	Kind renameLiteral `json:"kind"`
	// The old (existing) location.
	OldURI DocumentURI `json:"oldUri"`
	// The new location.
	NewURI DocumentURI `json:"newUri"`
	// Rename options.
	Options *RenameFileOptions `json:"options,omitempty"`
}

func (x *RenameFile) UnmarshalJSON(data []byte) error {
	type plain RenameFile
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Kind

	if x.OldURI == (DocumentURI{}) {
		return errors.New("\"oldUri\" property is required")
	}

	if x.NewURI == (DocumentURI{}) {
		return errors.New("\"newUri\" property is required")
	}

	return nil
}

// renameLiteral is a type that must be represented as the JSON-string "rename".
type renameLiteral struct{}

func (renameLiteral) MarshalJSON() ([]byte, error) {
	return marshal("rename")
}
func (*renameLiteral) UnmarshalJSON(data []byte) error {
	var value string
	if err := unmarshal(data, &value); err != nil {
		return err
	}

	if value != "rename" {
		return errors.New("value must be \"rename\"")
	}

	return nil
}

// Rename file options
type RenameFileOptions struct {
	// Overwrite target if existing. Overwrite wins over `ignoreIfExists`
	Overwrite bool `json:"overwrite,omitempty"`
	// Ignores if target exists.
	IgnoreIfExists bool `json:"ignoreIfExists,omitempty"`
}

func (x *RenameFileOptions) UnmarshalJSON(data []byte) error {
	type plain RenameFileOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters sent in notifications/requests for user-initiated renames of
// files.
//
// @since 3.16.0
type RenameFilesParams struct {
	// An array of all files/folders renamed in this operation. When a folder is renamed, only
	// the folder will be included, and not its children.
	Files []FileRename `json:"files"`
}

func (x *RenameFilesParams) UnmarshalJSON(data []byte) error {
	type plain RenameFilesParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Files == nil {
		return errors.New("\"files\" property is required")
	}

	return nil
}

// Provider options for a {@link RenameRequest}.
type RenameOptions struct {
	WorkDoneProgressOptions
	// Renames should be checked and tested before being executed.
	//
	// @since version 3.12.0
	PrepareProvider bool `json:"prepareProvider,omitempty"`
}

func (x *RenameOptions) UnmarshalJSON(data []byte) error {
	type plain RenameOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters of a {@link RenameRequest}.
type RenameParams struct {
	WorkDoneProgressParams
	// The document to rename.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The position at which this request was sent.
	Position Position `json:"position"`
	// The new name of the symbol. If the given name is not valid the
	// request must return a {@link ResponseError} with an
	// appropriate message set.
	NewName string `json:"newName"`
}

func (x *RenameParams) UnmarshalJSON(data []byte) error {
	type plain RenameParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	var _ json.Unmarshaler = &x.Position

	if x.NewName == "" {
		return errors.New("\"newName\" property is required")
	}

	return nil
}

// Registration options for a {@link RenameRequest}.
type RenameRegistrationOptions struct {
	TextDocumentRegistrationOptions
	RenameOptions
}

func (x *RenameRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain RenameRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A generic resource operation.
type ResourceOperation struct {
	// The resource operation kind.
	Kind string `json:"kind"`
	// An optional annotation identifier describing the operation.
	//
	// @since 3.16.0
	AnnotationId ChangeAnnotationIdentifier `json:"annotationId,omitempty"`
}

func (x *ResourceOperation) UnmarshalJSON(data []byte) error {
	type plain ResourceOperation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Kind == "" {
		return errors.New("\"kind\" property is required")
	}

	return nil
}

// Save options.
type SaveOptions struct {
	// The client is supposed to include the content on save.
	IncludeText bool `json:"includeText,omitempty"`
}

func (x *SaveOptions) UnmarshalJSON(data []byte) error {
	type plain SaveOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A selection range represents a part of a selection hierarchy. A selection range
// may have a parent selection range that contains it.
type SelectionRange struct {
	// The {@link Range range} of this selection range.
	Range Range `json:"range"`
	// The parent selection range containing this range. Therefore `parent.range` must contain `this.range`.
	Parent *SelectionRange `json:"parent,omitempty"`
}

func (x *SelectionRange) UnmarshalJSON(data []byte) error {
	type plain SelectionRange
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	return nil
}

type SelectionRangeClientCapabilities struct {
	// Whether implementation supports dynamic registration for selection range providers. If this is set to `true`
	// the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server
	// capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *SelectionRangeClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain SelectionRangeClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type SelectionRangeOptions struct {
	WorkDoneProgressOptions
}

func (x *SelectionRangeOptions) UnmarshalJSON(data []byte) error {
	type plain SelectionRangeOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A parameter literal used in selection range requests.
type SelectionRangeParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The positions inside the text document.
	Positions []Position `json:"positions"`
}

func (x *SelectionRangeParams) UnmarshalJSON(data []byte) error {
	type plain SelectionRangeParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	if x.Positions == nil {
		return errors.New("\"positions\" property is required")
	}

	return nil
}

type SelectionRangeRegistrationOptions struct {
	SelectionRangeOptions
	TextDocumentRegistrationOptions
	StaticRegistrationOptions
}

func (x *SelectionRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain SelectionRangeRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// @since 3.16.0
type SemanticTokens struct {
	// An optional result id. If provided and clients support delta updating
	// the client will include the result id in the next semantic token request.
	// A server can then instead of computing all semantic tokens again simply
	// send a delta.
	ResultId string `json:"resultId,omitempty"`
	// The actual tokens.
	Data []uint32 `json:"data"`
}

func (x *SemanticTokens) UnmarshalJSON(data []byte) error {
	type plain SemanticTokens
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Data == nil {
		return errors.New("\"data\" property is required")
	}

	return nil
}

// @since 3.16.0
type SemanticTokensClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Which requests the client supports and might send to the server
	// depending on the server's capability. Please note that clients might not
	// show semantic tokens or degrade some of the user experience if a range
	// or full request is advertised by the client but not provided by the
	// server. If for example the client capability `requests.full` and
	// `request.range` are both set to true but the server only provides a
	// range provider the client might not render a minimap correctly or might
	// even decide to not show any semantic tokens at all.
	Requests SemanticTokensClientCapabilitiesRequests `json:"requests"`
	// The token types that the client supports.
	TokenTypes []string `json:"tokenTypes"`
	// The token modifiers that the client supports.
	TokenModifiers []string `json:"tokenModifiers"`
	// The token formats the clients supports.
	Formats []TokenFormat `json:"formats"`
	// Whether the client supports tokens that can overlap each other.
	OverlappingTokenSupport bool `json:"overlappingTokenSupport,omitempty"`
	// Whether the client supports tokens that can span multiple lines.
	MultilineTokenSupport bool `json:"multilineTokenSupport,omitempty"`
	// Whether the client allows the server to actively cancel a
	// semantic token request, e.g. supports returning
	// LSPErrorCodes.ServerCancelled. If a server does the client
	// needs to retrigger the request.
	//
	// @since 3.17.0
	ServerCancelSupport bool `json:"serverCancelSupport,omitempty"`
	// Whether the client uses semantic tokens to augment existing
	// syntax tokens. If set to `true` client side created syntax
	// tokens and semantic tokens are both used for colorization. If
	// set to `false` the client only uses the returned semantic tokens
	// for colorization.
	//
	// If the value is `undefined` then the client behavior is not
	// specified.
	//
	// @since 3.17.0
	AugmentsSyntaxTokens bool `json:"augmentsSyntaxTokens,omitempty"`
}

func (x *SemanticTokensClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Requests

	if x.TokenTypes == nil {
		return errors.New("\"tokenTypes\" property is required")
	}

	if x.TokenModifiers == nil {
		return errors.New("\"tokenModifiers\" property is required")
	}

	if x.Formats == nil {
		return errors.New("\"formats\" property is required")
	}

	return nil
}

type SemanticTokensClientCapabilitiesRequestsRange struct{}

func (x *SemanticTokensClientCapabilitiesRequestsRange) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensClientCapabilitiesRequestsRange
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type SemanticTokensClientCapabilitiesRequestsFull struct {
	// The client will send the `textDocument/semanticTokens/full/delta` request if
	// the server provides a corresponding handler.
	Delta bool `json:"delta,omitempty"`
}

func (x *SemanticTokensClientCapabilitiesRequestsFull) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensClientCapabilitiesRequestsFull
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type SemanticTokensClientCapabilitiesRequests struct {
	// The client will send the `textDocument/semanticTokens/range` request if
	// the server provides a corresponding handler.
	Range *OneOf2[bool, SemanticTokensClientCapabilitiesRequestsRange] `json:"range,omitempty"`
	// The client will send the `textDocument/semanticTokens/full` request if
	// the server provides a corresponding handler.
	Full *OneOf2[bool, SemanticTokensClientCapabilitiesRequestsFull] `json:"full,omitempty"`
}

func (x *SemanticTokensClientCapabilitiesRequests) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensClientCapabilitiesRequests
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// @since 3.16.0
type SemanticTokensDelta struct {
	ResultId string `json:"resultId,omitempty"`
	// The semantic token edits to transform a previous result into a new result.
	Edits []SemanticTokensEdit `json:"edits"`
}

func (x *SemanticTokensDelta) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensDelta
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Edits == nil {
		return errors.New("\"edits\" property is required")
	}

	return nil
}

// @since 3.16.0
type SemanticTokensDeltaParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The result id of a previous response. The result Id can either point to a full response
	// or a delta response depending on what was received last.
	PreviousResultId string `json:"previousResultId"`
}

func (x *SemanticTokensDeltaParams) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensDeltaParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	if x.PreviousResultId == "" {
		return errors.New("\"previousResultId\" property is required")
	}

	return nil
}

// @since 3.16.0
type SemanticTokensDeltaPartialResult struct {
	Edits []SemanticTokensEdit `json:"edits"`
}

func (x *SemanticTokensDeltaPartialResult) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensDeltaPartialResult
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Edits == nil {
		return errors.New("\"edits\" property is required")
	}

	return nil
}

// @since 3.16.0
type SemanticTokensEdit struct {
	// The start offset of the edit.
	Start uint32 `json:"start"`
	// The count of elements to remove.
	DeleteCount uint32 `json:"deleteCount"`
	// The elements to insert.
	Data []uint32 `json:"data,omitempty"`
}

func (x *SemanticTokensEdit) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensEdit
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Start == 0 {
		return errors.New("\"start\" property is required")
	}

	if x.DeleteCount == 0 {
		return errors.New("\"deleteCount\" property is required")
	}

	return nil
}

// @since 3.16.0
type SemanticTokensLegend struct {
	// The token types a server uses.
	TokenTypes []string `json:"tokenTypes"`
	// The token modifiers a server uses.
	TokenModifiers []string `json:"tokenModifiers"`
}

func (x *SemanticTokensLegend) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensLegend
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.TokenTypes == nil {
		return errors.New("\"tokenTypes\" property is required")
	}

	if x.TokenModifiers == nil {
		return errors.New("\"tokenModifiers\" property is required")
	}

	return nil
}

// @since 3.16.0
type SemanticTokensOptions struct {
	WorkDoneProgressOptions
	// The legend used by the server
	Legend SemanticTokensLegend `json:"legend"`
	// Server supports providing semantic tokens for a specific range
	// of a document.
	Range *OneOf2[bool, SemanticTokensOptionsRange] `json:"range,omitempty"`
	// Server supports providing semantic tokens for a full document.
	Full *OneOf2[bool, SemanticTokensOptionsFull] `json:"full,omitempty"`
}

func (x *SemanticTokensOptions) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Legend

	return nil
}

type SemanticTokensOptionsRange struct{}

func (x *SemanticTokensOptionsRange) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensOptionsRange
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type SemanticTokensOptionsFull struct {
	// The server supports deltas for full documents.
	Delta bool `json:"delta,omitempty"`
}

func (x *SemanticTokensOptionsFull) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensOptionsFull
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// @since 3.16.0
type SemanticTokensParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (x *SemanticTokensParams) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	return nil
}

// @since 3.16.0
type SemanticTokensPartialResult struct {
	Data []uint32 `json:"data"`
}

func (x *SemanticTokensPartialResult) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensPartialResult
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Data == nil {
		return errors.New("\"data\" property is required")
	}

	return nil
}

// @since 3.16.0
type SemanticTokensRangeParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The range the semantic tokens are requested for.
	Range Range `json:"range"`
}

func (x *SemanticTokensRangeParams) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensRangeParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	var _ json.Unmarshaler = &x.Range

	return nil
}

// @since 3.16.0
type SemanticTokensRegistrationOptions struct {
	TextDocumentRegistrationOptions
	SemanticTokensOptions
	StaticRegistrationOptions
}

func (x *SemanticTokensRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// @since 3.16.0
type SemanticTokensWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from
	// the server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// semantic tokens currently shown. It should be used with absolute care
	// and is useful for situation where a server for example detects a project
	// wide change that requires such a calculation.
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

func (x *SemanticTokensWorkspaceClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain SemanticTokensWorkspaceClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Defines the capabilities provided by a language
// server.
type ServerCapabilities struct {
	// The position encoding the server picked from the encodings offered
	// by the client via the client capability `general.positionEncodings`.
	//
	// If the client didn't provide any position encodings the only valid
	// value that a server can return is 'utf-16'.
	//
	// If omitted it defaults to 'utf-16'.
	//
	// @since 3.17.0
	PositionEncoding PositionEncodingKind `json:"positionEncoding,omitempty"`
	// Defines how text documents are synced. Is either a detailed structure
	// defining each notification or for backwards compatibility the
	// TextDocumentSyncKind number.
	TextDocumentSync *OneOf2[TextDocumentSyncOptions, TextDocumentSyncKind] `json:"textDocumentSync,omitempty"`
	// Defines how notebook documents are synced.
	//
	// @since 3.17.0
	NotebookDocumentSync *OneOf2[NotebookDocumentSyncOptions, NotebookDocumentSyncRegistrationOptions] `json:"notebookDocumentSync,omitempty"`
	// The server provides completion support.
	CompletionProvider *CompletionOptions `json:"completionProvider,omitempty"`
	// The server provides hover support.
	HoverProvider *OneOf2[bool, HoverOptions] `json:"hoverProvider,omitempty"`
	// The server provides signature help support.
	SignatureHelpProvider *SignatureHelpOptions `json:"signatureHelpProvider,omitempty"`
	// The server provides Goto Declaration support.
	DeclarationProvider *OneOf3[bool, DeclarationOptions, DeclarationRegistrationOptions] `json:"declarationProvider,omitempty"`
	// The server provides goto definition support.
	DefinitionProvider *OneOf2[bool, DefinitionOptions] `json:"definitionProvider,omitempty"`
	// The server provides Goto Type Definition support.
	TypeDefinitionProvider *OneOf3[bool, TypeDefinitionOptions, TypeDefinitionRegistrationOptions] `json:"typeDefinitionProvider,omitempty"`
	// The server provides Goto Implementation support.
	ImplementationProvider *OneOf3[bool, ImplementationOptions, ImplementationRegistrationOptions] `json:"implementationProvider,omitempty"`
	// The server provides find references support.
	ReferencesProvider *OneOf2[bool, ReferenceOptions] `json:"referencesProvider,omitempty"`
	// The server provides document highlight support.
	DocumentHighlightProvider *OneOf2[bool, DocumentHighlightOptions] `json:"documentHighlightProvider,omitempty"`
	// The server provides document symbol support.
	DocumentSymbolProvider *OneOf2[bool, DocumentSymbolOptions] `json:"documentSymbolProvider,omitempty"`
	// The server provides code actions. CodeActionOptions may only be
	// specified if the client states that it supports
	// `codeActionLiteralSupport` in its initial `initialize` request.
	CodeActionProvider *OneOf2[bool, CodeActionOptions] `json:"codeActionProvider,omitempty"`
	// The server provides code lens.
	CodeLensProvider *CodeLensOptions `json:"codeLensProvider,omitempty"`
	// The server provides document link support.
	DocumentLinkProvider *DocumentLinkOptions `json:"documentLinkProvider,omitempty"`
	// The server provides color provider support.
	ColorProvider *OneOf3[bool, DocumentColorOptions, DocumentColorRegistrationOptions] `json:"colorProvider,omitempty"`
	// The server provides workspace symbol support.
	WorkspaceSymbolProvider *OneOf2[bool, WorkspaceSymbolOptions] `json:"workspaceSymbolProvider,omitempty"`
	// The server provides document formatting.
	DocumentFormattingProvider *OneOf2[bool, DocumentFormattingOptions] `json:"documentFormattingProvider,omitempty"`
	// The server provides document range formatting.
	DocumentRangeFormattingProvider *OneOf2[bool, DocumentRangeFormattingOptions] `json:"documentRangeFormattingProvider,omitempty"`
	// The server provides document formatting on typing.
	DocumentOnTypeFormattingProvider *DocumentOnTypeFormattingOptions `json:"documentOnTypeFormattingProvider,omitempty"`
	// The server provides rename support. RenameOptions may only be
	// specified if the client states that it supports
	// `prepareSupport` in its initial `initialize` request.
	RenameProvider *OneOf2[bool, RenameOptions] `json:"renameProvider,omitempty"`
	// The server provides folding provider support.
	FoldingRangeProvider *OneOf3[bool, FoldingRangeOptions, FoldingRangeRegistrationOptions] `json:"foldingRangeProvider,omitempty"`
	// The server provides selection range support.
	SelectionRangeProvider *OneOf3[bool, SelectionRangeOptions, SelectionRangeRegistrationOptions] `json:"selectionRangeProvider,omitempty"`
	// The server provides execute command support.
	ExecuteCommandProvider *ExecuteCommandOptions `json:"executeCommandProvider,omitempty"`
	// The server provides call hierarchy support.
	//
	// @since 3.16.0
	CallHierarchyProvider *OneOf3[bool, CallHierarchyOptions, CallHierarchyRegistrationOptions] `json:"callHierarchyProvider,omitempty"`
	// The server provides linked editing range support.
	//
	// @since 3.16.0
	LinkedEditingRangeProvider *OneOf3[bool, LinkedEditingRangeOptions, LinkedEditingRangeRegistrationOptions] `json:"linkedEditingRangeProvider,omitempty"`
	// The server provides semantic tokens support.
	//
	// @since 3.16.0
	SemanticTokensProvider *OneOf2[SemanticTokensOptions, SemanticTokensRegistrationOptions] `json:"semanticTokensProvider,omitempty"`
	// The server provides moniker support.
	//
	// @since 3.16.0
	MonikerProvider *OneOf3[bool, MonikerOptions, MonikerRegistrationOptions] `json:"monikerProvider,omitempty"`
	// The server provides type hierarchy support.
	//
	// @since 3.17.0
	TypeHierarchyProvider *OneOf3[bool, TypeHierarchyOptions, TypeHierarchyRegistrationOptions] `json:"typeHierarchyProvider,omitempty"`
	// The server provides inline values.
	//
	// @since 3.17.0
	InlineValueProvider *OneOf3[bool, InlineValueOptions, InlineValueRegistrationOptions] `json:"inlineValueProvider,omitempty"`
	// The server provides inlay hints.
	//
	// @since 3.17.0
	InlayHintProvider *OneOf3[bool, InlayHintOptions, InlayHintRegistrationOptions] `json:"inlayHintProvider,omitempty"`
	// The server has support for pull model diagnostics.
	//
	// @since 3.17.0
	DiagnosticProvider *OneOf2[DiagnosticOptions, DiagnosticRegistrationOptions] `json:"diagnosticProvider,omitempty"`
	// Workspace specific server capabilities.
	Workspace *ServerCapabilitiesWorkspace `json:"workspace,omitempty"`
	// Experimental server capabilities.
	Experimental any `json:"experimental,omitempty"`
}

func (x *ServerCapabilities) UnmarshalJSON(data []byte) error {
	type plain ServerCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type ServerCapabilitiesWorkspace struct {
	// The server supports workspace folder.
	//
	// @since 3.6.0
	WorkspaceFolders *WorkspaceFoldersServerCapabilities `json:"workspaceFolders,omitempty"`
	// The server is interested in notifications/requests for operations on files.
	//
	// @since 3.16.0
	FileOperations *FileOperationOptions `json:"fileOperations,omitempty"`
}

func (x *ServerCapabilitiesWorkspace) UnmarshalJSON(data []byte) error {
	type plain ServerCapabilitiesWorkspace
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type SetTraceParams struct {
	Value TraceValues `json:"value"`
}

func (x *SetTraceParams) UnmarshalJSON(data []byte) error {
	type plain SetTraceParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Value == "" {
		return errors.New("\"value\" property is required")
	}

	return nil
}

// Client capabilities for the showDocument request.
//
// @since 3.16.0
type ShowDocumentClientCapabilities struct {
	// The client has support for the showDocument
	// request.
	Support bool `json:"support"`
}

func (x *ShowDocumentClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain ShowDocumentClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Support == false {
		return errors.New("\"support\" property is required")
	}

	return nil
}

// Params to show a resource in the UI.
//
// @since 3.16.0
type ShowDocumentParams struct {
	// The uri to show.
	URI URI `json:"uri"`
	// Indicates to show the resource in an external program.
	// To show, for example, `https://code.visualstudio.com/`
	// in the default WEB browser set `external` to `true`.
	External bool `json:"external,omitempty"`
	// An optional property to indicate whether the editor
	// showing the document should take focus or not.
	// Clients might ignore this property if an external
	// program is started.
	TakeFocus bool `json:"takeFocus,omitempty"`
	// An optional selection range if the document is a text
	// document. Clients might ignore the property if an
	// external program is started or the file is not a text
	// file.
	Selection *Range `json:"selection,omitempty"`
}

func (x *ShowDocumentParams) UnmarshalJSON(data []byte) error {
	type plain ShowDocumentParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (URI{}) {
		return errors.New("\"uri\" property is required")
	}

	return nil
}

// The result of a showDocument request.
//
// @since 3.16.0
type ShowDocumentResult struct {
	// A boolean indicating if the show was successful.
	Success bool `json:"success"`
}

func (x *ShowDocumentResult) UnmarshalJSON(data []byte) error {
	type plain ShowDocumentResult
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Success == false {
		return errors.New("\"success\" property is required")
	}

	return nil
}

// The parameters of a notification message.
type ShowMessageParams struct {
	// The message type. See {@link MessageType}
	Type MessageType `json:"type"`
	// The actual message.
	Message string `json:"message"`
}

func (x *ShowMessageParams) UnmarshalJSON(data []byte) error {
	type plain ShowMessageParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Type == 0 {
		return errors.New("\"type\" property is required")
	}

	if x.Message == "" {
		return errors.New("\"message\" property is required")
	}

	return nil
}

// Show message request client capabilities
type ShowMessageRequestClientCapabilities struct {
	// Capabilities specific to the `MessageActionItem` type.
	MessageActionItem *ShowMessageRequestClientCapabilitiesMessageActionItem `json:"messageActionItem,omitempty"`
}

func (x *ShowMessageRequestClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain ShowMessageRequestClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type ShowMessageRequestClientCapabilitiesMessageActionItem struct {
	// Whether the client supports additional attributes which
	// are preserved and send back to the server in the
	// request's response.
	AdditionalPropertiesSupport bool `json:"additionalPropertiesSupport,omitempty"`
}

func (x *ShowMessageRequestClientCapabilitiesMessageActionItem) UnmarshalJSON(data []byte) error {
	type plain ShowMessageRequestClientCapabilitiesMessageActionItem
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type ShowMessageRequestParams struct {
	// The message type. See {@link MessageType}
	Type MessageType `json:"type"`
	// The actual message.
	Message string `json:"message"`
	// The message action items to present.
	Actions []MessageActionItem `json:"actions,omitempty"`
}

func (x *ShowMessageRequestParams) UnmarshalJSON(data []byte) error {
	type plain ShowMessageRequestParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Type == 0 {
		return errors.New("\"type\" property is required")
	}

	if x.Message == "" {
		return errors.New("\"message\" property is required")
	}

	return nil
}

// Signature help represents the signature of something
// callable. There can be multiple signature but only one
// active and only one active parameter.
type SignatureHelp struct {
	// One or more signatures.
	Signatures []SignatureInformation `json:"signatures"`
	// The active signature. If omitted or the value lies outside the
	// range of `signatures` the value defaults to zero or is ignored if
	// the `SignatureHelp` has no signatures.
	//
	// Whenever possible implementors should make an active decision about
	// the active signature and shouldn't rely on a default value.
	//
	// In future version of the protocol this property might become
	// mandatory to better express this.
	ActiveSignature uint32 `json:"activeSignature,omitempty"`
	// The active parameter of the active signature. If omitted or the value
	// lies outside the range of `signatures[activeSignature].parameters`
	// defaults to 0 if the active signature has parameters. If
	// the active signature has no parameters it is ignored.
	// In future version of the protocol this property might become
	// mandatory to better express the active parameter if the
	// active signature does have any.
	ActiveParameter uint32 `json:"activeParameter,omitempty"`
}

func (x *SignatureHelp) UnmarshalJSON(data []byte) error {
	type plain SignatureHelp
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Signatures == nil {
		return errors.New("\"signatures\" property is required")
	}

	return nil
}

// Client Capabilities for a {@link SignatureHelpRequest}.
type SignatureHelpClientCapabilities struct {
	// Whether signature help supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports the following `SignatureInformation`
	// specific properties.
	SignatureInformation *SignatureHelpClientCapabilitiesSignatureInformation `json:"signatureInformation,omitempty"`
	// The client supports to send additional context information for a
	// `textDocument/signatureHelp` request. A client that opts into
	// contextSupport will also support the `retriggerCharacters` on
	// `SignatureHelpOptions`.
	//
	// @since 3.15.0
	ContextSupport bool `json:"contextSupport,omitempty"`
}

func (x *SignatureHelpClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain SignatureHelpClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type SignatureHelpClientCapabilitiesSignatureInformationParameterInformation struct {
	// The client supports processing label offsets instead of a
	// simple label string.
	//
	// @since 3.14.0
	LabelOffsetSupport bool `json:"labelOffsetSupport,omitempty"`
}

func (x *SignatureHelpClientCapabilitiesSignatureInformationParameterInformation) UnmarshalJSON(data []byte) error {
	type plain SignatureHelpClientCapabilitiesSignatureInformationParameterInformation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type SignatureHelpClientCapabilitiesSignatureInformation struct {
	// Client supports the following content formats for the documentation
	// property. The order describes the preferred format of the client.
	DocumentationFormat []MarkupKind `json:"documentationFormat,omitempty"`
	// Client capabilities specific to parameter information.
	ParameterInformation *SignatureHelpClientCapabilitiesSignatureInformationParameterInformation `json:"parameterInformation,omitempty"`
	// The client supports the `activeParameter` property on `SignatureInformation`
	// literal.
	//
	// @since 3.16.0
	ActiveParameterSupport bool `json:"activeParameterSupport,omitempty"`
}

func (x *SignatureHelpClientCapabilitiesSignatureInformation) UnmarshalJSON(data []byte) error {
	type plain SignatureHelpClientCapabilitiesSignatureInformation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Additional information about the context in which a signature help request was triggered.
//
// @since 3.15.0
type SignatureHelpContext struct {
	// Action that caused signature help to be triggered.
	TriggerKind SignatureHelpTriggerKind `json:"triggerKind"`
	// Character that caused signature help to be triggered.
	//
	// This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter`
	TriggerCharacter string `json:"triggerCharacter,omitempty"`
	// `true` if signature help was already showing when it was triggered.
	//
	// Retriggers occurs when the signature help is already active and can be caused by actions such as
	// typing a trigger character, a cursor move, or document content changes.
	IsRetrigger bool `json:"isRetrigger"`
	// The currently active `SignatureHelp`.
	//
	// The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on
	// the user navigating through available signatures.
	ActiveSignatureHelp *SignatureHelp `json:"activeSignatureHelp,omitempty"`
}

func (x *SignatureHelpContext) UnmarshalJSON(data []byte) error {
	type plain SignatureHelpContext
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.TriggerKind == 0 {
		return errors.New("\"triggerKind\" property is required")
	}

	if x.IsRetrigger == false {
		return errors.New("\"isRetrigger\" property is required")
	}

	return nil
}

// Server Capabilities for a {@link SignatureHelpRequest}.
type SignatureHelpOptions struct {
	WorkDoneProgressOptions
	// List of characters that trigger signature help automatically.
	TriggerCharacters []string `json:"triggerCharacters,omitempty"`
	// List of characters that re-trigger signature help.
	//
	// These trigger characters are only active when signature help is already showing. All trigger characters
	// are also counted as re-trigger characters.
	//
	// @since 3.15.0
	RetriggerCharacters []string `json:"retriggerCharacters,omitempty"`
}

func (x *SignatureHelpOptions) UnmarshalJSON(data []byte) error {
	type plain SignatureHelpOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Parameters for a {@link SignatureHelpRequest}.
type SignatureHelpParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
	// The signature help context. This is only available if the client specifies
	// to send this using the client capability `textDocument.signatureHelp.contextSupport === true`
	//
	// @since 3.15.0
	Context *SignatureHelpContext `json:"context,omitempty"`
}

func (x *SignatureHelpParams) UnmarshalJSON(data []byte) error {
	type plain SignatureHelpParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Registration options for a {@link SignatureHelpRequest}.
type SignatureHelpRegistrationOptions struct {
	TextDocumentRegistrationOptions
	SignatureHelpOptions
}

func (x *SignatureHelpRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain SignatureHelpRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Represents the signature of something callable. A signature
// can have a label, like a function-name, a doc-comment, and
// a set of parameters.
type SignatureInformation struct {
	// The label of this signature. Will be shown in
	// the UI.
	Label string `json:"label"`
	// The human-readable doc-comment of this signature. Will be shown
	// in the UI but can be omitted.
	Documentation *OneOf2[string, MarkupContent] `json:"documentation,omitempty"`
	// The parameters of this signature.
	Parameters []ParameterInformation `json:"parameters,omitempty"`
	// The index of the active parameter.
	//
	// If provided, this is used in place of `SignatureHelp.activeParameter`.
	//
	// @since 3.16.0
	ActiveParameter uint32 `json:"activeParameter,omitempty"`
}

func (x *SignatureInformation) UnmarshalJSON(data []byte) error {
	type plain SignatureInformation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Label == "" {
		return errors.New("\"label\" property is required")
	}

	return nil
}

// Static registration options to be returned in the initialize
// request.
type StaticRegistrationOptions struct {
	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id string `json:"id,omitempty"`
}

func (x *StaticRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain StaticRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Represents information about programming constructs like variables, classes,
// interfaces etc.
type SymbolInformation struct {
	BaseSymbolInformation
	// Indicates if this symbol is deprecated.
	//
	// @deprecated Use tags instead
	Deprecated bool `json:"deprecated,omitempty"`
	// The location of this symbol. The location's range is used by a tool
	// to reveal the location in the editor. If the symbol is selected in the
	// tool the range's start information is used to position the cursor. So
	// the range usually spans more than the actual symbol's name and does
	// normally include things like visibility modifiers.
	//
	// The range doesn't have to denote a node range in the sense of an abstract
	// syntax tree. It can therefore not be used to re-construct a hierarchy of
	// the symbols.
	Location Location `json:"location"`
}

func (x *SymbolInformation) UnmarshalJSON(data []byte) error {
	type plain SymbolInformation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Location

	return nil
}

// Describe options to be used when registered for text document change events.
type TextDocumentChangeRegistrationOptions struct {
	TextDocumentRegistrationOptions
	// How documents are synced to the server.
	SyncKind TextDocumentSyncKind `json:"syncKind"`
}

func (x *TextDocumentChangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain TextDocumentChangeRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.SyncKind == 0 {
		return errors.New("\"syncKind\" property is required")
	}

	return nil
}

// Text document specific client capabilities.
type TextDocumentClientCapabilities struct {
	// Defines which synchronization capabilities the client supports.
	Synchronization *TextDocumentSyncClientCapabilities `json:"synchronization,omitempty"`
	// Capabilities specific to the `textDocument/completion` request.
	Completion *CompletionClientCapabilities `json:"completion,omitempty"`
	// Capabilities specific to the `textDocument/hover` request.
	Hover *HoverClientCapabilities `json:"hover,omitempty"`
	// Capabilities specific to the `textDocument/signatureHelp` request.
	SignatureHelp *SignatureHelpClientCapabilities `json:"signatureHelp,omitempty"`
	// Capabilities specific to the `textDocument/declaration` request.
	//
	// @since 3.14.0
	Declaration *DeclarationClientCapabilities `json:"declaration,omitempty"`
	// Capabilities specific to the `textDocument/definition` request.
	Definition *DefinitionClientCapabilities `json:"definition,omitempty"`
	// Capabilities specific to the `textDocument/typeDefinition` request.
	//
	// @since 3.6.0
	TypeDefinition *TypeDefinitionClientCapabilities `json:"typeDefinition,omitempty"`
	// Capabilities specific to the `textDocument/implementation` request.
	//
	// @since 3.6.0
	Implementation *ImplementationClientCapabilities `json:"implementation,omitempty"`
	// Capabilities specific to the `textDocument/references` request.
	References *ReferenceClientCapabilities `json:"references,omitempty"`
	// Capabilities specific to the `textDocument/documentHighlight` request.
	DocumentHighlight *DocumentHighlightClientCapabilities `json:"documentHighlight,omitempty"`
	// Capabilities specific to the `textDocument/documentSymbol` request.
	DocumentSymbol *DocumentSymbolClientCapabilities `json:"documentSymbol,omitempty"`
	// Capabilities specific to the `textDocument/codeAction` request.
	CodeAction *CodeActionClientCapabilities `json:"codeAction,omitempty"`
	// Capabilities specific to the `textDocument/codeLens` request.
	CodeLens *CodeLensClientCapabilities `json:"codeLens,omitempty"`
	// Capabilities specific to the `textDocument/documentLink` request.
	DocumentLink *DocumentLinkClientCapabilities `json:"documentLink,omitempty"`
	// Capabilities specific to the `textDocument/documentColor` and the
	// `textDocument/colorPresentation` request.
	//
	// @since 3.6.0
	ColorProvider *DocumentColorClientCapabilities `json:"colorProvider,omitempty"`
	// Capabilities specific to the `textDocument/formatting` request.
	Formatting *DocumentFormattingClientCapabilities `json:"formatting,omitempty"`
	// Capabilities specific to the `textDocument/rangeFormatting` request.
	RangeFormatting *DocumentRangeFormattingClientCapabilities `json:"rangeFormatting,omitempty"`
	// Capabilities specific to the `textDocument/onTypeFormatting` request.
	OnTypeFormatting *DocumentOnTypeFormattingClientCapabilities `json:"onTypeFormatting,omitempty"`
	// Capabilities specific to the `textDocument/rename` request.
	Rename *RenameClientCapabilities `json:"rename,omitempty"`
	// Capabilities specific to the `textDocument/foldingRange` request.
	//
	// @since 3.10.0
	FoldingRange *FoldingRangeClientCapabilities `json:"foldingRange,omitempty"`
	// Capabilities specific to the `textDocument/selectionRange` request.
	//
	// @since 3.15.0
	SelectionRange *SelectionRangeClientCapabilities `json:"selectionRange,omitempty"`
	// Capabilities specific to the `textDocument/publishDiagnostics` notification.
	PublishDiagnostics *PublishDiagnosticsClientCapabilities `json:"publishDiagnostics,omitempty"`
	// Capabilities specific to the various call hierarchy requests.
	//
	// @since 3.16.0
	CallHierarchy *CallHierarchyClientCapabilities `json:"callHierarchy,omitempty"`
	// Capabilities specific to the various semantic token request.
	//
	// @since 3.16.0
	SemanticTokens *SemanticTokensClientCapabilities `json:"semanticTokens,omitempty"`
	// Capabilities specific to the `textDocument/linkedEditingRange` request.
	//
	// @since 3.16.0
	LinkedEditingRange *LinkedEditingRangeClientCapabilities `json:"linkedEditingRange,omitempty"`
	// Client capabilities specific to the `textDocument/moniker` request.
	//
	// @since 3.16.0
	Moniker *MonikerClientCapabilities `json:"moniker,omitempty"`
	// Capabilities specific to the various type hierarchy requests.
	//
	// @since 3.17.0
	TypeHierarchy *TypeHierarchyClientCapabilities `json:"typeHierarchy,omitempty"`
	// Capabilities specific to the `textDocument/inlineValue` request.
	//
	// @since 3.17.0
	InlineValue *InlineValueClientCapabilities `json:"inlineValue,omitempty"`
	// Capabilities specific to the `textDocument/inlayHint` request.
	//
	// @since 3.17.0
	InlayHint *InlayHintClientCapabilities `json:"inlayHint,omitempty"`
	// Capabilities specific to the diagnostic pull model.
	//
	// @since 3.17.0
	Diagnostic *DiagnosticClientCapabilities `json:"diagnostic,omitempty"`
}

func (x *TextDocumentClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain TextDocumentClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Describes textual changes on a text document. A TextDocumentEdit describes all changes
// on a document version Si and after they are applied move the document to version Si+1.
// So the creator of a TextDocumentEdit doesn't need to sort the array of edits or do any
// kind of ordering. However the edits must be non overlapping.
type TextDocumentEdit struct {
	// The text document to change.
	TextDocument OptionalVersionedTextDocumentIdentifier `json:"textDocument"`
	// The edits to be applied.
	//
	// @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
	// client capability.
	Edits []OneOf2[TextEdit, AnnotatedTextEdit] `json:"edits"`
}

func (x *TextDocumentEdit) UnmarshalJSON(data []byte) error {
	type plain TextDocumentEdit
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	if x.Edits == nil {
		return errors.New("\"edits\" property is required")
	}

	return nil
}

// A literal to identify a text document in the client.
type TextDocumentIdentifier struct {
	// The text document's uri.
	URI DocumentURI `json:"uri"`
}

func (x *TextDocumentIdentifier) UnmarshalJSON(data []byte) error {
	type plain TextDocumentIdentifier
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	return nil
}

// An item to transfer a text document from the client to the
// server.
type TextDocumentItem struct {
	// The text document's uri.
	URI DocumentURI `json:"uri"`
	// The text document's language identifier.
	LanguageId string `json:"languageId"`
	// The version number of this document (it will increase after each
	// change, including undo/redo).
	Version int32 `json:"version"`
	// The content of the opened text document.
	Text string `json:"text"`
}

func (x *TextDocumentItem) UnmarshalJSON(data []byte) error {
	type plain TextDocumentItem
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	if x.LanguageId == "" {
		return errors.New("\"languageId\" property is required")
	}

	if x.Version == 0 {
		return errors.New("\"version\" property is required")
	}

	if x.Text == "" {
		return errors.New("\"text\" property is required")
	}

	return nil
}

// A parameter literal used in requests to pass a text document and a position inside that
// document.
type TextDocumentPositionParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The position inside the text document.
	Position Position `json:"position"`
}

func (x *TextDocumentPositionParams) UnmarshalJSON(data []byte) error {
	type plain TextDocumentPositionParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	var _ json.Unmarshaler = &x.Position

	return nil
}

// General text document registration options.
type TextDocumentRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelector `json:"documentSelector"`
}

func (x *TextDocumentRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain TextDocumentRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.DocumentSelector == nil {
		return errors.New("\"documentSelector\" property is required")
	}

	return nil
}

// Save registration options.
type TextDocumentSaveRegistrationOptions struct {
	TextDocumentRegistrationOptions
	SaveOptions
}

func (x *TextDocumentSaveRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain TextDocumentSaveRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type TextDocumentSyncClientCapabilities struct {
	// Whether text document synchronization supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports sending will save notifications.
	WillSave bool `json:"willSave,omitempty"`
	// The client supports sending a will save request and
	// waits for a response providing text edits which will
	// be applied to the document before it is saved.
	WillSaveWaitUntil bool `json:"willSaveWaitUntil,omitempty"`
	// The client supports did save notifications.
	DidSave bool `json:"didSave,omitempty"`
}

func (x *TextDocumentSyncClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain TextDocumentSyncClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type TextDocumentSyncOptions struct {
	// Open and close notifications are sent to the server. If omitted open close notification should not
	// be sent.
	OpenClose bool `json:"openClose,omitempty"`
	// Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
	// and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None.
	Change TextDocumentSyncKind `json:"change,omitempty"`
	// If present will save notifications are sent to the server. If omitted the notification should not be
	// sent.
	WillSave bool `json:"willSave,omitempty"`
	// If present will save wait until requests are sent to the server. If omitted the request should not be
	// sent.
	WillSaveWaitUntil bool `json:"willSaveWaitUntil,omitempty"`
	// If present save notifications are sent to the server. If omitted the notification should not be
	// sent.
	Save *OneOf2[bool, SaveOptions] `json:"save,omitempty"`
}

func (x *TextDocumentSyncOptions) UnmarshalJSON(data []byte) error {
	type plain TextDocumentSyncOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A text edit applicable to a text document.
type TextEdit struct {
	// The range of the text document to be manipulated. To insert
	// text into a document create a range where start === end.
	Range Range `json:"range"`
	// The string to be inserted. For delete operations use an
	// empty string.
	NewText string `json:"newText"`
}

func (x *TextEdit) UnmarshalJSON(data []byte) error {
	type plain TextEdit
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	if x.NewText == "" {
		return errors.New("\"newText\" property is required")
	}

	return nil
}

// Since 3.6.0
type TypeDefinitionClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `TypeDefinitionRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports additional metadata in the form of definition links.
	//
	// Since 3.14.0
	LinkSupport bool `json:"linkSupport,omitempty"`
}

func (x *TypeDefinitionClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain TypeDefinitionClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type TypeDefinitionOptions struct {
	WorkDoneProgressOptions
}

func (x *TypeDefinitionOptions) UnmarshalJSON(data []byte) error {
	type plain TypeDefinitionOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type TypeDefinitionParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
	PartialResultParams
}

func (x *TypeDefinitionParams) UnmarshalJSON(data []byte) error {
	type plain TypeDefinitionParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type TypeDefinitionRegistrationOptions struct {
	TextDocumentRegistrationOptions
	TypeDefinitionOptions
	StaticRegistrationOptions
}

func (x *TypeDefinitionRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain TypeDefinitionRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// @since 3.17.0
type TypeHierarchyClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

func (x *TypeHierarchyClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain TypeHierarchyClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// @since 3.17.0
type TypeHierarchyItem struct {
	// The name of this item.
	Name string `json:"name"`
	// The kind of this item.
	Kind SymbolKind `json:"kind"`
	// Tags for this item.
	Tags []SymbolTag `json:"tags,omitempty"`
	// More detail for this item, e.g. the signature of a function.
	Detail string `json:"detail,omitempty"`
	// The resource identifier of this item.
	URI DocumentURI `json:"uri"`
	// The range enclosing this symbol not including leading/trailing whitespace
	// but everything else, e.g. comments and code.
	Range Range `json:"range"`
	// The range that should be selected and revealed when this symbol is being
	// picked, e.g. the name of a function. Must be contained by the
	// {@link TypeHierarchyItem.range `range`}.
	SelectionRange Range `json:"selectionRange"`
	// A data entry field that is preserved between a type hierarchy prepare and
	// supertypes or subtypes requests. It could also be used to identify the
	// type hierarchy in the server, helping improve the performance on
	// resolving supertypes and subtypes.
	Data any `json:"data,omitempty"`
}

func (x *TypeHierarchyItem) UnmarshalJSON(data []byte) error {
	type plain TypeHierarchyItem
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Name == "" {
		return errors.New("\"name\" property is required")
	}

	if x.Kind == 0 {
		return errors.New("\"kind\" property is required")
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	var _ json.Unmarshaler = &x.Range

	var _ json.Unmarshaler = &x.SelectionRange

	return nil
}

// Type hierarchy options used during static registration.
//
// @since 3.17.0
type TypeHierarchyOptions struct {
	WorkDoneProgressOptions
}

func (x *TypeHierarchyOptions) UnmarshalJSON(data []byte) error {
	type plain TypeHierarchyOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameter of a `textDocument/prepareTypeHierarchy` request.
//
// @since 3.17.0
type TypeHierarchyPrepareParams struct {
	TextDocumentPositionParams
	WorkDoneProgressParams
}

func (x *TypeHierarchyPrepareParams) UnmarshalJSON(data []byte) error {
	type plain TypeHierarchyPrepareParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Type hierarchy options used during static or dynamic registration.
//
// @since 3.17.0
type TypeHierarchyRegistrationOptions struct {
	TextDocumentRegistrationOptions
	TypeHierarchyOptions
	StaticRegistrationOptions
}

func (x *TypeHierarchyRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain TypeHierarchyRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameter of a `typeHierarchy/subtypes` request.
//
// @since 3.17.0
type TypeHierarchySubtypesParams struct {
	WorkDoneProgressParams
	PartialResultParams
	Item TypeHierarchyItem `json:"item"`
}

func (x *TypeHierarchySubtypesParams) UnmarshalJSON(data []byte) error {
	type plain TypeHierarchySubtypesParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Item

	return nil
}

// The parameter of a `typeHierarchy/supertypes` request.
//
// @since 3.17.0
type TypeHierarchySupertypesParams struct {
	WorkDoneProgressParams
	PartialResultParams
	Item TypeHierarchyItem `json:"item"`
}

func (x *TypeHierarchySupertypesParams) UnmarshalJSON(data []byte) error {
	type plain TypeHierarchySupertypesParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Item

	return nil
}

// A diagnostic report indicating that the last returned
// report is still accurate.
//
// @since 3.17.0
type UnchangedDocumentDiagnosticReport struct {
	// A document diagnostic report indicating
	// no changes to the last result. A server can
	// only return `unchanged` if result ids are
	// provided.
	Kind unchangedLiteral `json:"kind"`
	// A result id which will be sent on the next
	// diagnostic request for the same document.
	ResultId string `json:"resultId"`
}

func (x *UnchangedDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	type plain UnchangedDocumentDiagnosticReport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Kind

	if x.ResultId == "" {
		return errors.New("\"resultId\" property is required")
	}

	return nil
}

// unchangedLiteral is a type that must be represented as the JSON-string "unchanged".
type unchangedLiteral struct{}

func (unchangedLiteral) MarshalJSON() ([]byte, error) {
	return marshal("unchanged")
}
func (*unchangedLiteral) UnmarshalJSON(data []byte) error {
	var value string
	if err := unmarshal(data, &value); err != nil {
		return err
	}

	if value != "unchanged" {
		return errors.New("value must be \"unchanged\"")
	}

	return nil
}

// General parameters to unregister a request or notification.
type Unregistration struct {
	// The id used to unregister the request or notification. Usually an id
	// provided during the register request.
	Id string `json:"id"`
	// The method to unregister for.
	Method string `json:"method"`
}

func (x *Unregistration) UnmarshalJSON(data []byte) error {
	type plain Unregistration
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Id == "" {
		return errors.New("\"id\" property is required")
	}

	if x.Method == "" {
		return errors.New("\"method\" property is required")
	}

	return nil
}

type UnregistrationParams struct {
	Unregisterations []Unregistration `json:"unregisterations"`
}

func (x *UnregistrationParams) UnmarshalJSON(data []byte) error {
	type plain UnregistrationParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Unregisterations == nil {
		return errors.New("\"unregisterations\" property is required")
	}

	return nil
}

// A versioned notebook document identifier.
//
// @since 3.17.0
type VersionedNotebookDocumentIdentifier struct {
	// The version number of this notebook document.
	Version int32 `json:"version"`
	// The notebook document's uri.
	URI URI `json:"uri"`
}

func (x *VersionedNotebookDocumentIdentifier) UnmarshalJSON(data []byte) error {
	type plain VersionedNotebookDocumentIdentifier
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Version == 0 {
		return errors.New("\"version\" property is required")
	}

	if x.URI == (URI{}) {
		return errors.New("\"uri\" property is required")
	}

	return nil
}

// A text document identifier to denote a specific version of a text document.
type VersionedTextDocumentIdentifier struct {
	TextDocumentIdentifier
	// The version number of this document.
	Version int32 `json:"version"`
}

func (x *VersionedTextDocumentIdentifier) UnmarshalJSON(data []byte) error {
	type plain VersionedTextDocumentIdentifier
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Version == 0 {
		return errors.New("\"version\" property is required")
	}

	return nil
}

// The parameters sent in a will save text document notification.
type WillSaveTextDocumentParams struct {
	// The document that will be saved.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
	// The 'TextDocumentSaveReason'.
	Reason TextDocumentSaveReason `json:"reason"`
}

func (x *WillSaveTextDocumentParams) UnmarshalJSON(data []byte) error {
	type plain WillSaveTextDocumentParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.TextDocument

	if x.Reason == 0 {
		return errors.New("\"reason\" property is required")
	}

	return nil
}

type WindowClientCapabilities struct {
	// It indicates whether the client supports server initiated
	// progress using the `window/workDoneProgress/create` request.
	//
	// The capability also controls Whether client supports handling
	// of progress notifications. If set servers are allowed to report a
	// `workDoneProgress` property in the request specific server
	// capabilities.
	//
	// @since 3.15.0
	WorkDoneProgress bool `json:"workDoneProgress,omitempty"`
	// Capabilities specific to the showMessage request.
	//
	// @since 3.16.0
	ShowMessage *ShowMessageRequestClientCapabilities `json:"showMessage,omitempty"`
	// Capabilities specific to the showDocument request.
	//
	// @since 3.16.0
	ShowDocument *ShowDocumentClientCapabilities `json:"showDocument,omitempty"`
}

func (x *WindowClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain WindowClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type WorkDoneProgressBegin struct {
	Kind beginLiteral `json:"kind"`
	// Mandatory title of the progress operation. Used to briefly inform about
	// the kind of operation being performed.
	//
	// Examples: "Indexing" or "Linking dependencies".
	Title string `json:"title"`
	// Controls if a cancel button should show to allow the user to cancel the
	// long running operation. Clients that don't support cancellation are allowed
	// to ignore the setting.
	Cancellable bool `json:"cancellable,omitempty"`
	// Optional, more detailed associated progress message. Contains
	// complementary information to the `title`.
	//
	// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
	// If unset, the previous progress message (if any) is still valid.
	Message string `json:"message,omitempty"`
	// Optional progress percentage to display (value 100 is considered 100%).
	// If not provided infinite progress is assumed and clients are allowed
	// to ignore the `percentage` value in subsequent in report notifications.
	//
	// The value should be steadily rising. Clients are free to ignore values
	// that are not following this rule. The value range is [0, 100].
	Percentage uint32 `json:"percentage,omitempty"`
}

func (x *WorkDoneProgressBegin) UnmarshalJSON(data []byte) error {
	type plain WorkDoneProgressBegin
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Kind

	if x.Title == "" {
		return errors.New("\"title\" property is required")
	}

	return nil
}

// beginLiteral is a type that must be represented as the JSON-string "begin".
type beginLiteral struct{}

func (beginLiteral) MarshalJSON() ([]byte, error) {
	return marshal("begin")
}
func (*beginLiteral) UnmarshalJSON(data []byte) error {
	var value string
	if err := unmarshal(data, &value); err != nil {
		return err
	}

	if value != "begin" {
		return errors.New("value must be \"begin\"")
	}

	return nil
}

type WorkDoneProgressCancelParams struct {
	// The token to be used to report progress.
	Token ProgressToken `json:"token"`
}

func (x *WorkDoneProgressCancelParams) UnmarshalJSON(data []byte) error {
	type plain WorkDoneProgressCancelParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Token

	return nil
}

type WorkDoneProgressCreateParams struct {
	// The token to be used to report progress.
	Token ProgressToken `json:"token"`
}

func (x *WorkDoneProgressCreateParams) UnmarshalJSON(data []byte) error {
	type plain WorkDoneProgressCreateParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Token

	return nil
}

type WorkDoneProgressEnd struct {
	Kind endLiteral `json:"kind"`
	// Optional, a final message indicating to for example indicate the outcome
	// of the operation.
	Message string `json:"message,omitempty"`
}

func (x *WorkDoneProgressEnd) UnmarshalJSON(data []byte) error {
	type plain WorkDoneProgressEnd
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Kind

	return nil
}

// endLiteral is a type that must be represented as the JSON-string "end".
type endLiteral struct{}

func (endLiteral) MarshalJSON() ([]byte, error) {
	return marshal("end")
}
func (*endLiteral) UnmarshalJSON(data []byte) error {
	var value string
	if err := unmarshal(data, &value); err != nil {
		return err
	}

	if value != "end" {
		return errors.New("value must be \"end\"")
	}

	return nil
}

type WorkDoneProgressOptions struct {
	WorkDoneProgress bool `json:"workDoneProgress,omitempty"`
}

func (x *WorkDoneProgressOptions) UnmarshalJSON(data []byte) error {
	type plain WorkDoneProgressOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type WorkDoneProgressParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *ProgressToken `json:"workDoneToken,omitempty"`
}

func (x *WorkDoneProgressParams) UnmarshalJSON(data []byte) error {
	type plain WorkDoneProgressParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type WorkDoneProgressReport struct {
	Kind reportLiteral `json:"kind"`
	// Controls enablement state of a cancel button.
	//
	// Clients that don't support cancellation or don't support controlling the button's
	// enablement state are allowed to ignore the property.
	Cancellable bool `json:"cancellable,omitempty"`
	// Optional, more detailed associated progress message. Contains
	// complementary information to the `title`.
	//
	// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
	// If unset, the previous progress message (if any) is still valid.
	Message string `json:"message,omitempty"`
	// Optional progress percentage to display (value 100 is considered 100%).
	// If not provided infinite progress is assumed and clients are allowed
	// to ignore the `percentage` value in subsequent in report notifications.
	//
	// The value should be steadily rising. Clients are free to ignore values
	// that are not following this rule. The value range is [0, 100]
	Percentage uint32 `json:"percentage,omitempty"`
}

func (x *WorkDoneProgressReport) UnmarshalJSON(data []byte) error {
	type plain WorkDoneProgressReport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Kind

	return nil
}

// reportLiteral is a type that must be represented as the JSON-string "report".
type reportLiteral struct{}

func (reportLiteral) MarshalJSON() ([]byte, error) {
	return marshal("report")
}
func (*reportLiteral) UnmarshalJSON(data []byte) error {
	var value string
	if err := unmarshal(data, &value); err != nil {
		return err
	}

	if value != "report" {
		return errors.New("value must be \"report\"")
	}

	return nil
}

// Workspace specific client capabilities.
type WorkspaceClientCapabilities struct {
	// The client supports applying batch edits
	// to the workspace by supporting the request
	// 'workspace/applyEdit'
	ApplyEdit bool `json:"applyEdit,omitempty"`
	// Capabilities specific to `WorkspaceEdit`s.
	WorkspaceEdit *WorkspaceEditClientCapabilities `json:"workspaceEdit,omitempty"`
	// Capabilities specific to the `workspace/didChangeConfiguration` notification.
	DidChangeConfiguration *DidChangeConfigurationClientCapabilities `json:"didChangeConfiguration,omitempty"`
	// Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
	DidChangeWatchedFiles *DidChangeWatchedFilesClientCapabilities `json:"didChangeWatchedFiles,omitempty"`
	// Capabilities specific to the `workspace/symbol` request.
	Symbol *WorkspaceSymbolClientCapabilities `json:"symbol,omitempty"`
	// Capabilities specific to the `workspace/executeCommand` request.
	ExecuteCommand *ExecuteCommandClientCapabilities `json:"executeCommand,omitempty"`
	// The client has support for workspace folders.
	//
	// @since 3.6.0
	WorkspaceFolders bool `json:"workspaceFolders,omitempty"`
	// The client supports `workspace/configuration` requests.
	//
	// @since 3.6.0
	Configuration bool `json:"configuration,omitempty"`
	// Capabilities specific to the semantic token requests scoped to the
	// workspace.
	//
	// @since 3.16.0.
	SemanticTokens *SemanticTokensWorkspaceClientCapabilities `json:"semanticTokens,omitempty"`
	// Capabilities specific to the code lens requests scoped to the
	// workspace.
	//
	// @since 3.16.0.
	CodeLens *CodeLensWorkspaceClientCapabilities `json:"codeLens,omitempty"`
	// The client has support for file notifications/requests for user operations on files.
	//
	// Since 3.16.0
	FileOperations *FileOperationClientCapabilities `json:"fileOperations,omitempty"`
	// Capabilities specific to the inline values requests scoped to the
	// workspace.
	//
	// @since 3.17.0.
	InlineValue *InlineValueWorkspaceClientCapabilities `json:"inlineValue,omitempty"`
	// Capabilities specific to the inlay hint requests scoped to the
	// workspace.
	//
	// @since 3.17.0.
	InlayHint *InlayHintWorkspaceClientCapabilities `json:"inlayHint,omitempty"`
	// Capabilities specific to the diagnostic requests scoped to the
	// workspace.
	//
	// @since 3.17.0.
	Diagnostics *DiagnosticWorkspaceClientCapabilities `json:"diagnostics,omitempty"`
}

func (x *WorkspaceClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain WorkspaceClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// Parameters of the workspace diagnostic request.
//
// @since 3.17.0
type WorkspaceDiagnosticParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// The additional identifier provided during registration.
	Identifier string `json:"identifier,omitempty"`
	// The currently known diagnostic reports with their
	// previous result ids.
	PreviousResultIds []PreviousResultId `json:"previousResultIds"`
}

func (x *WorkspaceDiagnosticParams) UnmarshalJSON(data []byte) error {
	type plain WorkspaceDiagnosticParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.PreviousResultIds == nil {
		return errors.New("\"previousResultIds\" property is required")
	}

	return nil
}

// A workspace diagnostic report.
//
// @since 3.17.0
type WorkspaceDiagnosticReport struct {
	Items []WorkspaceDocumentDiagnosticReport `json:"items"`
}

func (x *WorkspaceDiagnosticReport) UnmarshalJSON(data []byte) error {
	type plain WorkspaceDiagnosticReport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Items == nil {
		return errors.New("\"items\" property is required")
	}

	return nil
}

// A partial result for a workspace diagnostic report.
//
// @since 3.17.0
type WorkspaceDiagnosticReportPartialResult struct {
	Items []WorkspaceDocumentDiagnosticReport `json:"items"`
}

func (x *WorkspaceDiagnosticReportPartialResult) UnmarshalJSON(data []byte) error {
	type plain WorkspaceDiagnosticReportPartialResult
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Items == nil {
		return errors.New("\"items\" property is required")
	}

	return nil
}

// A workspace edit represents changes to many resources managed in the workspace. The edit
// should either provide `changes` or `documentChanges`. If documentChanges are present
// they are preferred over `changes` if the client can handle versioned document edits.
//
// Since version 3.13.0 a workspace edit can contain resource operations as well. If resource
// operations are present clients need to execute the operations in the order in which they
// are provided. So a workspace edit for example can consist of the following two changes:
// (1) a create file a.txt and (2) a text document edit which insert text into file a.txt.
//
// An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will
// cause failure of the operation. How the client recovers from the failure is described by
// the client capability: `workspace.workspaceEdit.failureHandling`
type WorkspaceEdit struct {
	// Holds changes to existing resources.
	Changes map[DocumentURI][]TextEdit `json:"changes,omitempty"`
	// Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
	// are either an array of `TextDocumentEdit`s to express changes to n different text documents
	// where each text document edit addresses a specific version of a text document. Or it can contain
	// above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.
	//
	// Whether a client supports versioned document edits is expressed via
	// `workspace.workspaceEdit.documentChanges` client capability.
	//
	// If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
	// only plain `TextEdit`s using the `changes` property are supported.
	DocumentChanges []OneOf4[TextDocumentEdit, CreateFile, RenameFile, DeleteFile] `json:"documentChanges,omitempty"`
	// A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and
	// delete file / folder operations.
	//
	// Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.
	//
	// @since 3.16.0
	ChangeAnnotations map[ChangeAnnotationIdentifier]ChangeAnnotation `json:"changeAnnotations,omitempty"`
}

func (x *WorkspaceEdit) UnmarshalJSON(data []byte) error {
	type plain WorkspaceEdit
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type WorkspaceEditClientCapabilities struct {
	// The client supports versioned document changes in `WorkspaceEdit`s
	DocumentChanges bool `json:"documentChanges,omitempty"`
	// The resource operations the client supports. Clients should at least
	// support 'create', 'rename' and 'delete' files and folders.
	//
	// @since 3.13.0
	ResourceOperations []ResourceOperationKind `json:"resourceOperations,omitempty"`
	// The failure handling strategy of a client if applying the workspace edit
	// fails.
	//
	// @since 3.13.0
	FailureHandling FailureHandlingKind `json:"failureHandling,omitempty"`
	// Whether the client normalizes line endings to the client specific
	// setting.
	// If set to `true` the client will normalize line ending characters
	// in a workspace edit to the client-specified new line
	// character.
	//
	// @since 3.16.0
	NormalizesLineEndings bool `json:"normalizesLineEndings,omitempty"`
	// Whether the client in general supports change annotations on text edits,
	// create file, rename file and delete file changes.
	//
	// @since 3.16.0
	ChangeAnnotationSupport *WorkspaceEditClientCapabilitiesChangeAnnotationSupport `json:"changeAnnotationSupport,omitempty"`
}

func (x *WorkspaceEditClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain WorkspaceEditClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type WorkspaceEditClientCapabilitiesChangeAnnotationSupport struct {
	// Whether the client groups edits with equal labels into tree nodes,
	// for instance all edits labelled with "Changes in Strings" would
	// be a tree node.
	GroupsOnLabel bool `json:"groupsOnLabel,omitempty"`
}

func (x *WorkspaceEditClientCapabilitiesChangeAnnotationSupport) UnmarshalJSON(data []byte) error {
	type plain WorkspaceEditClientCapabilitiesChangeAnnotationSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A workspace folder inside a client.
type WorkspaceFolder struct {
	// The associated URI for this workspace folder.
	URI URI `json:"uri"`
	// The name of the workspace folder. Used to refer to this
	// workspace folder in the user interface.
	Name string `json:"name"`
}

func (x *WorkspaceFolder) UnmarshalJSON(data []byte) error {
	type plain WorkspaceFolder
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (URI{}) {
		return errors.New("\"uri\" property is required")
	}

	if x.Name == "" {
		return errors.New("\"name\" property is required")
	}

	return nil
}

// The workspace folder change event.
type WorkspaceFoldersChangeEvent struct {
	// The array of added workspace folders
	Added []WorkspaceFolder `json:"added"`
	// The array of the removed workspace folders
	Removed []WorkspaceFolder `json:"removed"`
}

func (x *WorkspaceFoldersChangeEvent) UnmarshalJSON(data []byte) error {
	type plain WorkspaceFoldersChangeEvent
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Added == nil {
		return errors.New("\"added\" property is required")
	}

	if x.Removed == nil {
		return errors.New("\"removed\" property is required")
	}

	return nil
}

type WorkspaceFoldersInitializeParams struct {
	// The workspace folders configured in the client when the server starts.
	//
	// This property is only available if the client supports workspace folders.
	// It can be `null` if the client supports workspace folders but none are
	// configured.
	//
	// @since 3.6.0
	WorkspaceFolders []WorkspaceFolder `json:"workspaceFolders,omitempty"`
}

func (x *WorkspaceFoldersInitializeParams) UnmarshalJSON(data []byte) error {
	type plain WorkspaceFoldersInitializeParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type WorkspaceFoldersServerCapabilities struct {
	// The server has support for workspace folders
	Supported bool `json:"supported,omitempty"`
	// Whether the server wants to receive workspace folder
	// change notifications.
	//
	// If a string is provided the string is treated as an ID
	// under which the notification is registered on the client
	// side. The ID can be used to unregister for these events
	// using the `client/unregisterCapability` request.
	ChangeNotifications *OneOf2[string, bool] `json:"changeNotifications,omitempty"`
}

func (x *WorkspaceFoldersServerCapabilities) UnmarshalJSON(data []byte) error {
	type plain WorkspaceFoldersServerCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// A full document diagnostic report for a workspace diagnostic result.
//
// @since 3.17.0
type WorkspaceFullDocumentDiagnosticReport struct {
	FullDocumentDiagnosticReport
	// The URI for which diagnostic information is reported.
	URI DocumentURI `json:"uri"`
	// The version number for which the diagnostics are reported.
	// If the document is not marked as open `null` can be provided.
	Version int32 `json:"version"`
}

func (x *WorkspaceFullDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	type plain WorkspaceFullDocumentDiagnosticReport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	if x.Version == 0 {
		return errors.New("\"version\" property is required")
	}

	return nil
}

// A special workspace symbol that supports locations without a range.
//
// See also SymbolInformation.
//
// @since 3.17.0
type WorkspaceSymbol struct {
	BaseSymbolInformation
	// The location of the symbol. Whether a server is allowed to
	// return a location without a range depends on the client
	// capability `workspace.symbol.resolveSupport`.
	//
	// See SymbolInformation#location for more details.
	Location OneOf2[Location, WorkspaceSymbolLocation] `json:"location"`
	// A data entry field that is preserved on a workspace symbol between a
	// workspace symbol request and a workspace symbol resolve request.
	Data any `json:"data,omitempty"`
}

func (x *WorkspaceSymbol) UnmarshalJSON(data []byte) error {
	type plain WorkspaceSymbol
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Location

	return nil
}

type WorkspaceSymbolLocation struct {
	URI DocumentURI `json:"uri"`
}

func (x *WorkspaceSymbolLocation) UnmarshalJSON(data []byte) error {
	type plain WorkspaceSymbolLocation
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	return nil
}

// Client capabilities for a {@link WorkspaceSymbolRequest}.
type WorkspaceSymbolClientCapabilities struct {
	// Symbol request supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
	SymbolKind *WorkspaceSymbolClientCapabilitiesSymbolKind `json:"symbolKind,omitempty"`
	// The client supports tags on `SymbolInformation`.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// @since 3.16.0
	TagSupport *WorkspaceSymbolClientCapabilitiesTagSupport `json:"tagSupport,omitempty"`
	// The client support partial workspace symbols. The client will send the
	// request `workspaceSymbol/resolve` to the server to resolve additional
	// properties.
	//
	// @since 3.17.0
	ResolveSupport *WorkspaceSymbolClientCapabilitiesResolveSupport `json:"resolveSupport,omitempty"`
}

func (x *WorkspaceSymbolClientCapabilities) UnmarshalJSON(data []byte) error {
	type plain WorkspaceSymbolClientCapabilities
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type WorkspaceSymbolClientCapabilitiesSymbolKind struct {
	// The symbol kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	//
	// If this property is not present the client only supports
	// the symbol kinds from `File` to `Array` as defined in
	// the initial version of the protocol.
	ValueSet []SymbolKind `json:"valueSet,omitempty"`
}

func (x *WorkspaceSymbolClientCapabilitiesSymbolKind) UnmarshalJSON(data []byte) error {
	type plain WorkspaceSymbolClientCapabilitiesSymbolKind
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

type WorkspaceSymbolClientCapabilitiesTagSupport struct {
	// The tags supported by the client.
	ValueSet []SymbolTag `json:"valueSet"`
}

func (x *WorkspaceSymbolClientCapabilitiesTagSupport) UnmarshalJSON(data []byte) error {
	type plain WorkspaceSymbolClientCapabilitiesTagSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.ValueSet == nil {
		return errors.New("\"valueSet\" property is required")
	}

	return nil
}

type WorkspaceSymbolClientCapabilitiesResolveSupport struct {
	// The properties that a client can resolve lazily. Usually
	// `location.range`
	Properties []string `json:"properties"`
}

func (x *WorkspaceSymbolClientCapabilitiesResolveSupport) UnmarshalJSON(data []byte) error {
	type plain WorkspaceSymbolClientCapabilitiesResolveSupport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Properties == nil {
		return errors.New("\"properties\" property is required")
	}

	return nil
}

// Server capabilities for a {@link WorkspaceSymbolRequest}.
type WorkspaceSymbolOptions struct {
	WorkDoneProgressOptions
	// The server provides support to resolve additional
	// information for a workspace symbol.
	//
	// @since 3.17.0
	ResolveProvider bool `json:"resolveProvider,omitempty"`
}

func (x *WorkspaceSymbolOptions) UnmarshalJSON(data []byte) error {
	type plain WorkspaceSymbolOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// The parameters of a {@link WorkspaceSymbolRequest}.
type WorkspaceSymbolParams struct {
	WorkDoneProgressParams
	PartialResultParams
	// A query string to filter symbols by. Clients may send an empty
	// string here to request all symbols.
	Query string `json:"query"`
}

func (x *WorkspaceSymbolParams) UnmarshalJSON(data []byte) error {
	type plain WorkspaceSymbolParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Query == "" {
		return errors.New("\"query\" property is required")
	}

	return nil
}

// Registration options for a {@link WorkspaceSymbolRequest}.
type WorkspaceSymbolRegistrationOptions struct {
	WorkspaceSymbolOptions
}

func (x *WorkspaceSymbolRegistrationOptions) UnmarshalJSON(data []byte) error {
	type plain WorkspaceSymbolRegistrationOptions
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	return nil
}

// An unchanged document diagnostic report for a workspace diagnostic result.
//
// @since 3.17.0
type WorkspaceUnchangedDocumentDiagnosticReport struct {
	UnchangedDocumentDiagnosticReport
	// The URI for which diagnostic information is reported.
	URI DocumentURI `json:"uri"`
	// The version number for which the diagnostics are reported.
	// If the document is not marked as open `null` can be provided.
	Version int32 `json:"version"`
}

func (x *WorkspaceUnchangedDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	type plain WorkspaceUnchangedDocumentDiagnosticReport
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.URI == (DocumentURI{}) {
		return errors.New("\"uri\" property is required")
	}

	if x.Version == 0 {
		return errors.New("\"version\" property is required")
	}

	return nil
}

// The initialize parameters
type _InitializeParams struct {
	WorkDoneProgressParams
	// The process Id of the parent process that started
	// the server.
	//
	// Is `null` if the process has not been started by another process.
	// If the parent process is not alive then the server should exit.
	ProcessId int32 `json:"processId"`
	// Information about the client
	//
	// @since 3.15.0
	ClientInfo *_InitializeParamsClientInfo `json:"clientInfo,omitempty"`
	// The locale the client is currently showing the user interface
	// in. This must not necessarily be the locale of the operating
	// system.
	//
	// Uses IETF language tags as the value's syntax
	// (See https://en.wikipedia.org/wiki/IETF_language_tag)
	//
	// @since 3.16.0
	Locale string `json:"locale,omitempty"`
	// The rootPath of the workspace. Is null
	// if no folder is open.
	//
	// @deprecated in favour of rootUri.
	RootPath string `json:"rootPath,omitempty"`
	// The rootUri of the workspace. Is null if no
	// folder is open. If both `rootPath` and `rootUri` are set
	// `rootUri` wins.
	//
	// @deprecated in favour of workspaceFolders.
	RootURI DocumentURI `json:"rootUri"`
	// The capabilities provided by the client (editor or tool)
	Capabilities ClientCapabilities `json:"capabilities"`
	// User provided initialization options.
	InitializationOptions any `json:"initializationOptions,omitempty"`
	// The initial trace setting. If omitted trace is disabled ('off').
	Trace TraceValues `json:"trace,omitempty"`
}

func (x *_InitializeParams) UnmarshalJSON(data []byte) error {
	type plain _InitializeParams
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.ProcessId == 0 {
		return errors.New("\"processId\" property is required")
	}

	if x.RootURI == (DocumentURI{}) {
		return errors.New("\"rootUri\" property is required")
	}

	var _ json.Unmarshaler = &x.Capabilities

	return nil
}

type _InitializeParamsClientInfo struct {
	// The name of the client as defined by the client.
	Name string `json:"name"`
	// The client's version as defined by the client.
	Version string `json:"version,omitempty"`
}

func (x *_InitializeParamsClientInfo) UnmarshalJSON(data []byte) error {
	type plain _InitializeParamsClientInfo
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Name == "" {
		return errors.New("\"name\" property is required")
	}

	return nil
}

// ---------------------------------------------------------------------------------------------------------------------
// ENUMERATIONS
// ---------------------------------------------------------------------------------------------------------------------

// A set of predefined code action kinds
type CodeActionKind string

const (
	// Empty kind.
	CodeActionKindEmpty CodeActionKind = ""
	// Base kind for quickfix actions: 'quickfix'
	CodeActionKindQuickFix CodeActionKind = "quickfix"
	// Base kind for refactoring actions: 'refactor'
	CodeActionKindRefactor CodeActionKind = "refactor"
	// Base kind for refactoring extraction actions: 'refactor.extract'
	//
	// Example extract actions:
	//
	// - Extract method
	// - Extract function
	// - Extract variable
	// - Extract interface from class
	// - ...
	CodeActionKindRefactorExtract CodeActionKind = "refactor.extract"
	// Base kind for refactoring inline actions: 'refactor.inline'
	//
	// Example inline actions:
	//
	// - Inline function
	// - Inline variable
	// - Inline constant
	// - ...
	CodeActionKindRefactorInline CodeActionKind = "refactor.inline"
	// Base kind for refactoring rewrite actions: 'refactor.rewrite'
	//
	// Example rewrite actions:
	//
	// - Convert JavaScript function to class
	// - Add or remove parameter
	// - Encapsulate field
	// - Make method static
	// - Move method to base class
	// - ...
	CodeActionKindRefactorRewrite CodeActionKind = "refactor.rewrite"
	// Base kind for source actions: `source`
	//
	// Source code actions apply to the entire file.
	CodeActionKindSource CodeActionKind = "source"
	// Base kind for an organize imports source action: `source.organizeImports`
	CodeActionKindSourceOrganizeImports CodeActionKind = "source.organizeImports"
	// Base kind for auto-fix source actions: `source.fixAll`.
	//
	// Fix all actions automatically fix errors that have a clear fix that do not require user input.
	// They should not suppress errors or perform unsafe fixes such as generating new types or classes.
	//
	// @since 3.15.0
	CodeActionKindSourceFixAll CodeActionKind = "source.fixAll"
)

// The reason why code actions were requested.
//
// @since 3.17.0
type CodeActionTriggerKind uint32

const (
	// Code actions were explicitly requested by the user or by an extension.
	CodeActionTriggerKindInvoked CodeActionTriggerKind = 1
	// Code actions were requested automatically.
	//
	// This typically happens when current selection in a file changes, but can
	// also be triggered when file content changes.
	CodeActionTriggerKindAutomatic CodeActionTriggerKind = 2
)

// The kind of a completion entry.
type CompletionItemKind uint32

const (
	CompletionItemKindText          CompletionItemKind = 1
	CompletionItemKindMethod        CompletionItemKind = 2
	CompletionItemKindFunction      CompletionItemKind = 3
	CompletionItemKindConstructor   CompletionItemKind = 4
	CompletionItemKindField         CompletionItemKind = 5
	CompletionItemKindVariable      CompletionItemKind = 6
	CompletionItemKindClass         CompletionItemKind = 7
	CompletionItemKindInterface     CompletionItemKind = 8
	CompletionItemKindModule        CompletionItemKind = 9
	CompletionItemKindProperty      CompletionItemKind = 10
	CompletionItemKindUnit          CompletionItemKind = 11
	CompletionItemKindValue         CompletionItemKind = 12
	CompletionItemKindEnum          CompletionItemKind = 13
	CompletionItemKindKeyword       CompletionItemKind = 14
	CompletionItemKindSnippet       CompletionItemKind = 15
	CompletionItemKindColor         CompletionItemKind = 16
	CompletionItemKindFile          CompletionItemKind = 17
	CompletionItemKindReference     CompletionItemKind = 18
	CompletionItemKindFolder        CompletionItemKind = 19
	CompletionItemKindEnumMember    CompletionItemKind = 20
	CompletionItemKindConstant      CompletionItemKind = 21
	CompletionItemKindStruct        CompletionItemKind = 22
	CompletionItemKindEvent         CompletionItemKind = 23
	CompletionItemKindOperator      CompletionItemKind = 24
	CompletionItemKindTypeParameter CompletionItemKind = 25
)

// Completion item tags are extra annotations that tweak the rendering of a completion
// item.
//
// @since 3.15.0
type CompletionItemTag uint32

const (
	// Render a completion as obsolete, usually using a strike-out.
	CompletionItemTagDeprecated CompletionItemTag = 1
)

// How a completion was triggered
type CompletionTriggerKind uint32

const (
	// Completion was triggered by typing an identifier (24x7 code
	// complete), manual invocation (e.g Ctrl+Space) or via API.
	CompletionTriggerKindInvoked CompletionTriggerKind = 1
	// Completion was triggered by a trigger character specified by
	// the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
	CompletionTriggerKindTriggerCharacter CompletionTriggerKind = 2
	// Completion was re-triggered as current completion list is incomplete
	CompletionTriggerKindTriggerForIncompleteCompletions CompletionTriggerKind = 3
)

// The diagnostic's severity.
type DiagnosticSeverity uint32

const (
	// Reports an error.
	DiagnosticSeverityError DiagnosticSeverity = 1
	// Reports a warning.
	DiagnosticSeverityWarning DiagnosticSeverity = 2
	// Reports an information.
	DiagnosticSeverityInformation DiagnosticSeverity = 3
	// Reports a hint.
	DiagnosticSeverityHint DiagnosticSeverity = 4
)

// The diagnostic tags.
//
// @since 3.15.0
type DiagnosticTag uint32

const (
	// Unused or unnecessary code.
	//
	// Clients are allowed to render diagnostics with this tag faded out instead of having
	// an error squiggle.
	DiagnosticTagUnnecessary DiagnosticTag = 1
	// Deprecated or obsolete code.
	//
	// Clients are allowed to rendered diagnostics with this tag strike through.
	DiagnosticTagDeprecated DiagnosticTag = 2
)

// The document diagnostic report kinds.
//
// @since 3.17.0
type DocumentDiagnosticReportKind string

const (
	// A diagnostic report with a full
	// set of problems.
	DocumentDiagnosticReportKindFull DocumentDiagnosticReportKind = "full"
	// A report indicating that the last
	// returned report is still accurate.
	DocumentDiagnosticReportKindUnchanged DocumentDiagnosticReportKind = "unchanged"
)

// A document highlight kind.
type DocumentHighlightKind uint32

const (
	// A textual occurrence.
	DocumentHighlightKindText DocumentHighlightKind = 1
	// Read-access of a symbol, like reading a variable.
	DocumentHighlightKindRead DocumentHighlightKind = 2
	// Write-access of a symbol, like writing to a variable.
	DocumentHighlightKindWrite DocumentHighlightKind = 3
)

// Predefined error codes.
type ErrorCodes int32

const (
	ErrorCodesParseError     ErrorCodes = -32700
	ErrorCodesInvalidRequest ErrorCodes = -32600
	ErrorCodesMethodNotFound ErrorCodes = -32601
	ErrorCodesInvalidParams  ErrorCodes = -32602
	ErrorCodesInternalError  ErrorCodes = -32603
	// Error code indicating that a server received a notification or
	// request before the server has received the `initialize` request.
	ErrorCodesServerNotInitialized ErrorCodes = -32002
	ErrorCodesUnknownErrorCode     ErrorCodes = -32001
)

type FailureHandlingKind string

const (
	// Applying the workspace change is simply aborted if one of the changes provided
	// fails. All operations executed before the failing operation stay executed.
	FailureHandlingKindAbort FailureHandlingKind = "abort"
	// All operations are executed transactional. That means they either all
	// succeed or no changes at all are applied to the workspace.
	FailureHandlingKindTransactional FailureHandlingKind = "transactional"
	// If the workspace edit contains only textual file changes they are executed transactional.
	// If resource changes (create, rename or delete file) are part of the change the failure
	// handling strategy is abort.
	FailureHandlingKindTextOnlyTransactional FailureHandlingKind = "textOnlyTransactional"
	// The client tries to undo the operations already executed. But there is no
	// guarantee that this is succeeding.
	FailureHandlingKindUndo FailureHandlingKind = "undo"
)

// The file event type
type FileChangeType uint32

const (
	// The file got created.
	FileChangeTypeCreated FileChangeType = 1
	// The file got changed.
	FileChangeTypeChanged FileChangeType = 2
	// The file got deleted.
	FileChangeTypeDeleted FileChangeType = 3
)

// A pattern kind describing if a glob pattern matches a file a folder or
// both.
//
// @since 3.16.0
type FileOperationPatternKind string

const (
	// The pattern matches a file only.
	FileOperationPatternKindFile FileOperationPatternKind = "file"
	// The pattern matches a folder only.
	FileOperationPatternKindFolder FileOperationPatternKind = "folder"
)

// A set of predefined range kinds.
type FoldingRangeKind string

const (
	// Folding range for a comment
	FoldingRangeKindComment FoldingRangeKind = "comment"
	// Folding range for an import or include
	FoldingRangeKindImports FoldingRangeKind = "imports"
	// Folding range for a region (e.g. `#region`)
	FoldingRangeKindRegion FoldingRangeKind = "region"
)

// Inlay hint kinds.
//
// @since 3.17.0
type InlayHintKind uint32

const (
	// An inlay hint that for a type annotation.
	InlayHintKindType InlayHintKind = 1
	// An inlay hint that is for a parameter.
	InlayHintKindParameter InlayHintKind = 2
)

// Defines whether the insert text in a completion item should be interpreted as
// plain text or a snippet.
type InsertTextFormat uint32

const (
	// The primary text to be inserted is treated as a plain string.
	InsertTextFormatPlainText InsertTextFormat = 1
	// The primary text to be inserted is treated as a snippet.
	//
	// A snippet can define tab stops and placeholders with `$1`, `$2`
	// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
	// the end of the snippet. Placeholders with equal identifiers are linked,
	// that is typing in one will update others too.
	//
	// See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
	InsertTextFormatSnippet InsertTextFormat = 2
)

// How whitespace and indentation is handled during completion
// item insertion.
//
// @since 3.16.0
type InsertTextMode uint32

const (
	// The insertion or replace strings is taken as it is. If the
	// value is multi line the lines below the cursor will be
	// inserted using the indentation defined in the string value.
	// The client will not apply any kind of adjustments to the
	// string.
	InsertTextModeAsIs InsertTextMode = 1
	// The editor adjusts leading whitespace of new lines so that
	// they match the indentation up to the cursor of the line for
	// which the item is accepted.
	//
	// Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
	// multi line completion item is indented using 2 tabs and all
	// following lines inserted will be indented using 2 tabs as well.
	InsertTextModeAdjustIndentation InsertTextMode = 2
)

type LSPErrorCodes int32

const (
	// A request failed but it was syntactically correct, e.g the
	// method name was known and the parameters were valid. The error
	// message should contain human readable information about why
	// the request failed.
	//
	// @since 3.17.0
	LSPErrorCodesRequestFailed LSPErrorCodes = -32803
	// The server cancelled the request. This error code should
	// only be used for requests that explicitly support being
	// server cancellable.
	//
	// @since 3.17.0
	LSPErrorCodesServerCancelled LSPErrorCodes = -32802
	// The server detected that the content of a document got
	// modified outside normal conditions. A server should
	// NOT send this error code if it detects a content change
	// in it unprocessed messages. The result even computed
	// on an older state might still be useful for the client.
	//
	// If a client decides that a result is not of any use anymore
	// the client should cancel the request.
	LSPErrorCodesContentModified LSPErrorCodes = -32801
	// The client has canceled a request and a server as detected
	// the cancel.
	LSPErrorCodesRequestCancelled LSPErrorCodes = -32800
)

// Describes the content type that a client supports in various
// result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
//
// Please note that `MarkupKinds` must not start with a `$`. This kinds
// are reserved for internal usage.
type MarkupKind string

const (
	// Plain text is supported as a content format
	MarkupKindPlainText MarkupKind = "plaintext"
	// Markdown is supported as a content format
	MarkupKindMarkdown MarkupKind = "markdown"
)

// The message type
type MessageType uint32

const (
	// An error message.
	MessageTypeError MessageType = 1
	// A warning message.
	MessageTypeWarning MessageType = 2
	// An information message.
	MessageTypeInfo MessageType = 3
	// A log message.
	MessageTypeLog MessageType = 4
)

// The moniker kind.
//
// @since 3.16.0
type MonikerKind string

const (
	// The moniker represent a symbol that is imported into a project
	MonikerKindImport MonikerKind = "import"
	// The moniker represents a symbol that is exported from a project
	MonikerKindExport MonikerKind = "export"
	// The moniker represents a symbol that is local to a project (e.g. a local
	// variable of a function, a class not visible outside the project, ...)
	MonikerKindLocal MonikerKind = "local"
)

// A notebook cell kind.
//
// @since 3.17.0
type NotebookCellKind uint32

const (
	// A markup-cell is formatted source that is used for display.
	NotebookCellKindMarkup NotebookCellKind = 1
	// A code-cell is source code.
	NotebookCellKindCode NotebookCellKind = 2
)

// A set of predefined position encoding kinds.
//
// @since 3.17.0
type PositionEncodingKind string

const (
	// Character offsets count UTF-8 code units (e.g. bytes).
	PositionEncodingKindUTF8 PositionEncodingKind = "utf-8"
	// Character offsets count UTF-16 code units.
	//
	// This is the default and must always be supported
	// by servers
	PositionEncodingKindUTF16 PositionEncodingKind = "utf-16"
	// Character offsets count UTF-32 code units.
	//
	// Implementation note: these are the same as Unicode codepoints,
	// so this `PositionEncodingKind` may also be used for an
	// encoding-agnostic representation of character offsets.
	PositionEncodingKindUTF32 PositionEncodingKind = "utf-32"
)

type PrepareSupportDefaultBehavior uint32

const (
	// The client's default behavior is to select the identifier
	// according the to language's syntax rule.
	PrepareSupportDefaultBehaviorIdentifier PrepareSupportDefaultBehavior = 1
)

type ResourceOperationKind string

const (
	// Supports creating new files and folders.
	ResourceOperationKindCreate ResourceOperationKind = "create"
	// Supports renaming existing files and folders.
	ResourceOperationKindRename ResourceOperationKind = "rename"
	// Supports deleting existing files and folders.
	ResourceOperationKindDelete ResourceOperationKind = "delete"
)

// A set of predefined token modifiers. This set is not fixed
// an clients can specify additional token types via the
// corresponding client capabilities.
//
// @since 3.16.0
type SemanticTokenModifiers string

const (
	SemanticTokenModifiersDeclaration    SemanticTokenModifiers = "declaration"
	SemanticTokenModifiersDefinition     SemanticTokenModifiers = "definition"
	SemanticTokenModifiersReadonly       SemanticTokenModifiers = "readonly"
	SemanticTokenModifiersStatic         SemanticTokenModifiers = "static"
	SemanticTokenModifiersDeprecated     SemanticTokenModifiers = "deprecated"
	SemanticTokenModifiersAbstract       SemanticTokenModifiers = "abstract"
	SemanticTokenModifiersAsync          SemanticTokenModifiers = "async"
	SemanticTokenModifiersModification   SemanticTokenModifiers = "modification"
	SemanticTokenModifiersDocumentation  SemanticTokenModifiers = "documentation"
	SemanticTokenModifiersDefaultLibrary SemanticTokenModifiers = "defaultLibrary"
)

// A set of predefined token types. This set is not fixed
// an clients can specify additional token types via the
// corresponding client capabilities.
//
// @since 3.16.0
type SemanticTokenTypes string

const (
	SemanticTokenTypesNamespace SemanticTokenTypes = "namespace"
	// Represents a generic type. Acts as a fallback for types which can't be mapped to
	// a specific type like class or enum.
	SemanticTokenTypesType          SemanticTokenTypes = "type"
	SemanticTokenTypesClass         SemanticTokenTypes = "class"
	SemanticTokenTypesEnum          SemanticTokenTypes = "enum"
	SemanticTokenTypesInterface     SemanticTokenTypes = "interface"
	SemanticTokenTypesStruct        SemanticTokenTypes = "struct"
	SemanticTokenTypesTypeParameter SemanticTokenTypes = "typeParameter"
	SemanticTokenTypesParameter     SemanticTokenTypes = "parameter"
	SemanticTokenTypesVariable      SemanticTokenTypes = "variable"
	SemanticTokenTypesProperty      SemanticTokenTypes = "property"
	SemanticTokenTypesEnumMember    SemanticTokenTypes = "enumMember"
	SemanticTokenTypesEvent         SemanticTokenTypes = "event"
	SemanticTokenTypesFunction      SemanticTokenTypes = "function"
	SemanticTokenTypesMethod        SemanticTokenTypes = "method"
	SemanticTokenTypesMacro         SemanticTokenTypes = "macro"
	SemanticTokenTypesKeyword       SemanticTokenTypes = "keyword"
	SemanticTokenTypesModifier      SemanticTokenTypes = "modifier"
	SemanticTokenTypesComment       SemanticTokenTypes = "comment"
	SemanticTokenTypesString        SemanticTokenTypes = "string"
	SemanticTokenTypesNumber        SemanticTokenTypes = "number"
	SemanticTokenTypesRegexp        SemanticTokenTypes = "regexp"
	SemanticTokenTypesOperator      SemanticTokenTypes = "operator"
	// @since 3.17.0
	SemanticTokenTypesDecorator SemanticTokenTypes = "decorator"
)

// How a signature help was triggered.
//
// @since 3.15.0
type SignatureHelpTriggerKind uint32

const (
	// Signature help was invoked manually by the user or by a command.
	SignatureHelpTriggerKindInvoked SignatureHelpTriggerKind = 1
	// Signature help was triggered by a trigger character.
	SignatureHelpTriggerKindTriggerCharacter SignatureHelpTriggerKind = 2
	// Signature help was triggered by the cursor moving or by the document content changing.
	SignatureHelpTriggerKindContentChange SignatureHelpTriggerKind = 3
)

// A symbol kind.
type SymbolKind uint32

const (
	SymbolKindFile          SymbolKind = 1
	SymbolKindModule        SymbolKind = 2
	SymbolKindNamespace     SymbolKind = 3
	SymbolKindPackage       SymbolKind = 4
	SymbolKindClass         SymbolKind = 5
	SymbolKindMethod        SymbolKind = 6
	SymbolKindProperty      SymbolKind = 7
	SymbolKindField         SymbolKind = 8
	SymbolKindConstructor   SymbolKind = 9
	SymbolKindEnum          SymbolKind = 10
	SymbolKindInterface     SymbolKind = 11
	SymbolKindFunction      SymbolKind = 12
	SymbolKindVariable      SymbolKind = 13
	SymbolKindConstant      SymbolKind = 14
	SymbolKindString        SymbolKind = 15
	SymbolKindNumber        SymbolKind = 16
	SymbolKindBoolean       SymbolKind = 17
	SymbolKindArray         SymbolKind = 18
	SymbolKindObject        SymbolKind = 19
	SymbolKindKey           SymbolKind = 20
	SymbolKindNull          SymbolKind = 21
	SymbolKindEnumMember    SymbolKind = 22
	SymbolKindStruct        SymbolKind = 23
	SymbolKindEvent         SymbolKind = 24
	SymbolKindOperator      SymbolKind = 25
	SymbolKindTypeParameter SymbolKind = 26
)

// Symbol tags are extra annotations that tweak the rendering of a symbol.
//
// @since 3.16
type SymbolTag uint32

const (
	// Render a symbol as obsolete, usually using a strike-out.
	SymbolTagDeprecated SymbolTag = 1
)

// Represents reasons why a text document is saved.
type TextDocumentSaveReason uint32

const (
	// Manually triggered, e.g. by the user pressing save, by starting debugging,
	// or by an API call.
	TextDocumentSaveReasonManual TextDocumentSaveReason = 1
	// Automatic after a delay.
	TextDocumentSaveReasonAfterDelay TextDocumentSaveReason = 2
	// When the editor lost focus.
	TextDocumentSaveReasonFocusOut TextDocumentSaveReason = 3
)

// Defines how the host (editor) should sync
// document changes to the language server.
type TextDocumentSyncKind uint32

const (
	// Documents should not be synced at all.
	TextDocumentSyncKindNone TextDocumentSyncKind = 0
	// Documents are synced by always sending the full content
	// of the document.
	TextDocumentSyncKindFull TextDocumentSyncKind = 1
	// Documents are synced by sending the full content on open.
	// After that only incremental updates to the document are
	// send.
	TextDocumentSyncKindIncremental TextDocumentSyncKind = 2
)

type TokenFormat string

const (
	TokenFormatRelative TokenFormat = "relative"
)

type TraceValues string

const (
	// Turn tracing off.
	TraceValuesOff TraceValues = "off"
	// Trace messages only.
	TraceValuesMessages TraceValues = "messages"
	// Verbose message tracing.
	TraceValuesVerbose TraceValues = "verbose"
)

// Moniker uniqueness level to define scope of the moniker.
//
// @since 3.16.0
type UniquenessLevel string

const (
	// The moniker is only unique inside a document
	UniquenessLevelDocument UniquenessLevel = "document"
	// The moniker is unique inside a project for which a dump got created
	UniquenessLevelProject UniquenessLevel = "project"
	// The moniker is unique inside the group to which a project belongs
	UniquenessLevelGroup UniquenessLevel = "group"
	// The moniker is unique inside the moniker scheme.
	UniquenessLevelScheme UniquenessLevel = "scheme"
	// The moniker is globally unique
	UniquenessLevelGlobal UniquenessLevel = "global"
)

type WatchKind uint32

const (
	// Interested in create events.
	WatchKindCreate WatchKind = 1
	// Interested in change events
	WatchKindChange WatchKind = 2
	// Interested in delete events
	WatchKindDelete WatchKind = 4
)

// ---------------------------------------------------------------------------------------------------------------------
// TYPE ALIASES
// ---------------------------------------------------------------------------------------------------------------------

// An identifier to refer to a change annotation stored with a workspace edit.
type ChangeAnnotationIdentifier = string

// The declaration of a symbol representation as one or many {@link Location locations}.
type Declaration = OneOf2[Location, []Location]

// Information about where a symbol is declared.
//
// Provides additional metadata over normal {@link Location location} declarations, including the range of
// the declaring symbol.
//
// Servers should prefer returning `DeclarationLink` over `Declaration` if supported
// by the client.
type DeclarationLink = LocationLink

// The definition of a symbol represented as one or many {@link Location locations}.
// For most programming languages there is only one location at which a symbol is
// defined.
//
// Servers should prefer returning `DefinitionLink` over `Definition` if supported
// by the client.
type Definition = OneOf2[Location, []Location]

// Information about where a symbol is defined.
//
// Provides additional metadata over normal {@link Location location} definitions, including the range of
// the defining symbol
type DefinitionLink = LocationLink

// The result of a document diagnostic pull request. A report can
// either be a full report containing all diagnostics for the
// requested document or an unchanged report indicating that nothing
// has changed in terms of diagnostics in comparison to the last
// pull request.
//
// @since 3.17.0
type DocumentDiagnosticReport = OneOf2[RelatedFullDocumentDiagnosticReport, RelatedUnchangedDocumentDiagnosticReport]

// A document filter describes a top level text document or
// a notebook cell document.
//
// @since 3.17.0 - proposed support for NotebookCellTextDocumentFilter.
type DocumentFilter = OneOf2[TextDocumentFilter, NotebookCellTextDocumentFilter]

// A document selector is the combination of one or many document filters.
//
// @sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**∕tsconfig.json' }]`;
//
// The use of a string as a document filter is deprecated @since 3.16.0.
type DocumentSelector = []DocumentFilter

// The glob pattern. Either a string pattern or a relative pattern.
//
// @since 3.17.0
type GlobPattern = OneOf2[Pattern, RelativePattern]

// Inline value information can be provided by different means:
// - directly as a text value (class InlineValueText).
// - as a name to use for a variable lookup (class InlineValueVariableLookup)
// - as an evaluatable expression (class InlineValueEvaluatableExpression)
// The InlineValue types combines all inline value types into one type.
//
// @since 3.17.0
type InlineValue = OneOf3[InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression]

// MarkedString can be used to render human readable text. It is either a markdown string
// or a code-block that provides a language and a code snippet. The language identifier
// is semantically equal to the optional language identifier in fenced code blocks in GitHub
// issues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
//
// The pair of a language and a value is an equivalent to markdown:
// ```${language}
// ${value}
// ```
//
// Note that markdown strings will be sanitized - that means html will be escaped.
// @deprecated use MarkupContent instead.
type MarkedString = OneOf2[string, MarkedString1]
type MarkedString1 struct {
	Language string `json:"language"`
	Value    string `json:"value"`
}

func (x *MarkedString1) UnmarshalJSON(data []byte) error {
	type plain MarkedString1
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Language == "" {
		return errors.New("\"language\" property is required")
	}

	if x.Value == "" {
		return errors.New("\"value\" property is required")
	}

	return nil
}

// A notebook document filter denotes a notebook document by
// different properties. The properties will be match
// against the notebook's URI (same as with documents)
//
// @since 3.17.0
type NotebookDocumentFilter = OneOf3[NotebookDocumentFilter1, NotebookDocumentFilter2, NotebookDocumentFilter3]
type NotebookDocumentFilter1 struct {
	// The type of the enclosing notebook.
	NotebookType string `json:"notebookType"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme,omitempty"`
	// A glob pattern.
	Pattern string `json:"pattern,omitempty"`
}

func (x *NotebookDocumentFilter1) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentFilter1
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.NotebookType == "" {
		return errors.New("\"notebookType\" property is required")
	}

	return nil
}

type NotebookDocumentFilter2 struct {
	// The type of the enclosing notebook.
	NotebookType string `json:"notebookType,omitempty"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme"`
	// A glob pattern.
	Pattern string `json:"pattern,omitempty"`
}

func (x *NotebookDocumentFilter2) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentFilter2
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Scheme == "" {
		return errors.New("\"scheme\" property is required")
	}

	return nil
}

type NotebookDocumentFilter3 struct {
	// The type of the enclosing notebook.
	NotebookType string `json:"notebookType,omitempty"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme,omitempty"`
	// A glob pattern.
	Pattern string `json:"pattern"`
}

func (x *NotebookDocumentFilter3) UnmarshalJSON(data []byte) error {
	type plain NotebookDocumentFilter3
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Pattern == "" {
		return errors.New("\"pattern\" property is required")
	}

	return nil
}

// The glob pattern to watch relative to the base path. Glob patterns can have the following syntax:
// - `*` to match one or more characters in a path segment
// - `?` to match on one character in a path segment
// - `**` to match any number of path segments, including none
// - `{}` to group conditions (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
//
// @since 3.17.0
type Pattern = string

type PrepareRenameResult = OneOf3[Range, PrepareRenameResult1, PrepareRenameResult2]
type PrepareRenameResult1 struct {
	Range       Range  `json:"range"`
	Placeholder string `json:"placeholder"`
}

func (x *PrepareRenameResult1) UnmarshalJSON(data []byte) error {
	type plain PrepareRenameResult1
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	if x.Placeholder == "" {
		return errors.New("\"placeholder\" property is required")
	}

	return nil
}

type PrepareRenameResult2 struct {
	DefaultBehavior bool `json:"defaultBehavior"`
}

func (x *PrepareRenameResult2) UnmarshalJSON(data []byte) error {
	type plain PrepareRenameResult2
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.DefaultBehavior == false {
		return errors.New("\"defaultBehavior\" property is required")
	}

	return nil
}

type ProgressToken = OneOf2[int32, string]

// An event describing a change to a text document. If only a text is provided
// it is considered to be the full content of the document.
type TextDocumentContentChangeEvent = OneOf2[TextDocumentContentChangeEvent1, TextDocumentContentChangeEvent2]
type TextDocumentContentChangeEvent1 struct {
	// The range of the document that changed.
	Range Range `json:"range"`
	// The optional length of the range that got replaced.
	//
	// @deprecated use range instead.
	RangeLength uint32 `json:"rangeLength,omitempty"`
	// The new text for the provided range.
	Text string `json:"text"`
}

func (x *TextDocumentContentChangeEvent1) UnmarshalJSON(data []byte) error {
	type plain TextDocumentContentChangeEvent1
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	var _ json.Unmarshaler = &x.Range

	if x.Text == "" {
		return errors.New("\"text\" property is required")
	}

	return nil
}

type TextDocumentContentChangeEvent2 struct {
	// The new text of the whole document.
	Text string `json:"text"`
}

func (x *TextDocumentContentChangeEvent2) UnmarshalJSON(data []byte) error {
	type plain TextDocumentContentChangeEvent2
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Text == "" {
		return errors.New("\"text\" property is required")
	}

	return nil
}

// A document filter denotes a document by different properties like
// the {@link TextDocument.languageId language}, the {@link Uri.scheme scheme} of
// its resource, or a glob-pattern that is applied to the {@link TextDocument.fileName path}.
//
// Glob patterns can have the following syntax:
// - `*` to match one or more characters in a path segment
// - `?` to match on one character in a path segment
// - `**` to match any number of path segments, including none
// - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
//
// @sample A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`
// @sample A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**package.json' }`
//
// @since 3.17.0
type TextDocumentFilter = OneOf3[TextDocumentFilter1, TextDocumentFilter2, TextDocumentFilter3]
type TextDocumentFilter1 struct {
	// A language id, like `typescript`.
	Language string `json:"language"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme,omitempty"`
	// A glob pattern, like `*.{ts,js}`.
	Pattern string `json:"pattern,omitempty"`
}

func (x *TextDocumentFilter1) UnmarshalJSON(data []byte) error {
	type plain TextDocumentFilter1
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Language == "" {
		return errors.New("\"language\" property is required")
	}

	return nil
}

type TextDocumentFilter2 struct {
	// A language id, like `typescript`.
	Language string `json:"language,omitempty"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme"`
	// A glob pattern, like `*.{ts,js}`.
	Pattern string `json:"pattern,omitempty"`
}

func (x *TextDocumentFilter2) UnmarshalJSON(data []byte) error {
	type plain TextDocumentFilter2
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Scheme == "" {
		return errors.New("\"scheme\" property is required")
	}

	return nil
}

type TextDocumentFilter3 struct {
	// A language id, like `typescript`.
	Language string `json:"language,omitempty"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme,omitempty"`
	// A glob pattern, like `*.{ts,js}`.
	Pattern string `json:"pattern"`
}

func (x *TextDocumentFilter3) UnmarshalJSON(data []byte) error {
	type plain TextDocumentFilter3
	if err := unmarshal(data, (*plain)(x)); err != nil {
		return err
	}

	if x.Pattern == "" {
		return errors.New("\"pattern\" property is required")
	}

	return nil
}

// A workspace diagnostic document report.
//
// @since 3.17.0
type WorkspaceDocumentDiagnosticReport = OneOf2[WorkspaceFullDocumentDiagnosticReport, WorkspaceUnchangedDocumentDiagnosticReport]

// ---------------------------------------------------------------------------------------------------------------------
// UNIONS
// ---------------------------------------------------------------------------------------------------------------------

// OneOf2 is a union of 2 values.
type OneOf2[T0, T1 any] struct {
	First  *T0
	Second *T1
}

func (x OneOf2[T0, T1]) MarshalJSON() ([]byte, error) {
	switch {
	default:
		return marshal(x.First)
	case x.Second != nil:
		return marshal(x.Second)
	}
}

func (x *OneOf2[T0, T1]) UnmarshalJSON(data []byte) error {
	*x = OneOf2[T0, T1]{}

	var (
		errs []error
		err  error
	)

	err = unmarshal(data, &x.First)
	if err == nil {
		return nil
	}
	errs = append(errs, err)

	err = unmarshal(data, &x.Second)
	if err == nil {
		return nil
	}
	errs = append(errs, err)

	return errors.Join(errs...)
}

// OneOf3 is a union of 3 values.
type OneOf3[T0, T1, T2 any] struct {
	First  *T0
	Second *T1
	Third  *T2
}

func (x OneOf3[T0, T1, T2]) MarshalJSON() ([]byte, error) {
	switch {
	default:
		return marshal(x.First)
	case x.Second != nil:
		return marshal(x.Second)
	case x.Third != nil:
		return marshal(x.Third)
	}
}

func (x *OneOf3[T0, T1, T2]) UnmarshalJSON(data []byte) error {
	*x = OneOf3[T0, T1, T2]{}

	var (
		errs []error
		err  error
	)

	err = unmarshal(data, &x.First)
	if err == nil {
		return nil
	}
	errs = append(errs, err)

	err = unmarshal(data, &x.Second)
	if err == nil {
		return nil
	}
	errs = append(errs, err)

	err = unmarshal(data, &x.Third)
	if err == nil {
		return nil
	}
	errs = append(errs, err)

	return errors.Join(errs...)
}

// OneOf4 is a union of 4 values.
type OneOf4[T0, T1, T2, T3 any] struct {
	First  *T0
	Second *T1
	Third  *T2
	Fourth *T3
}

func (x OneOf4[T0, T1, T2, T3]) MarshalJSON() ([]byte, error) {
	switch {
	default:
		return marshal(x.First)
	case x.Second != nil:
		return marshal(x.Second)
	case x.Third != nil:
		return marshal(x.Third)
	case x.Fourth != nil:
		return marshal(x.Fourth)
	}
}

func (x *OneOf4[T0, T1, T2, T3]) UnmarshalJSON(data []byte) error {
	*x = OneOf4[T0, T1, T2, T3]{}

	var (
		errs []error
		err  error
	)

	err = unmarshal(data, &x.First)
	if err == nil {
		return nil
	}
	errs = append(errs, err)

	err = unmarshal(data, &x.Second)
	if err == nil {
		return nil
	}
	errs = append(errs, err)

	err = unmarshal(data, &x.Third)
	if err == nil {
		return nil
	}
	errs = append(errs, err)

	err = unmarshal(data, &x.Fourth)
	if err == nil {
		return nil
	}
	errs = append(errs, err)

	return errors.Join(errs...)
}
